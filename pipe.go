// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright 2017 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.

package pipe

import (
	"container/ring"
	"sync"
	"time"

	"github.com/cheekybits/genny/generic"
)

type Any generic.Type

// ===========================================================================
// Beg of MakeAny creators

// MakeAnyChan returns a new open channel
// (simply a 'chan Any' that is).
// Note: No 'Any-producer' is launched here yet! (as is in all the other functions).
//  This is useful to easily create corresponding variables such as:
/*
var myAnyPipelineStartsHere := MakeAnyChan()
// ... lot's of code to design and build Your favourite "myAnyWorkflowPipeline"
   // ...
   // ... *before* You start pouring data into it, e.g. simply via:
   for drop := range water {
myAnyPipelineStartsHere <- drop
   }
close(myAnyPipelineStartsHere)
*/
//  Hint: especially helpful, if Your piping library operates on some hidden (non-exported) type
//  (or on a type imported from elsewhere - and You don't want/need or should(!) have to care.)
//
// Note: as always (except for PipeAnyBuffer) the channel is unbuffered.
//
func MakeAnyChan() (out chan Any) {
	return make(chan Any)
}

// End of MakeAny creators
// ===========================================================================

// ===========================================================================
// Beg of ChanAny producers

// ChanAny returns a channel to receive
// all inputs
// before close.
func ChanAny(inp ...Any) (out <-chan Any) {
	cha := make(chan Any)
	go chanAny(cha, inp...)
	return cha
}

func chanAny(out chan<- Any, inp ...Any) {
	defer close(out)
	for i := range inp {
		out <- inp[i]
	}
}

// ChanAnySlice returns a channel to receive
// all inputs
// before close.
func ChanAnySlice(inp ...[]Any) (out <-chan Any) {
	cha := make(chan Any)
	go chanAnySlice(cha, inp...)
	return cha
}

func chanAnySlice(out chan<- Any, inp ...[]Any) {
	defer close(out)
	for i := range inp {
		for j := range inp[i] {
			out <- inp[i][j]
		}
	}
}

// ChanAnyFuncNok returns a channel to receive
// all results of generator `gen`
// until `!ok`
// before close.
func ChanAnyFuncNok(gen func() (Any, bool)) (out <-chan Any) {
	cha := make(chan Any)
	go chanAnyFuncNok(cha, gen)
	return cha
}

func chanAnyFuncNok(out chan<- Any, gen func() (Any, bool)) {
	defer close(out)
	for {
		res, ok := gen() // generate
		if !ok {
			return
		}
		out <- res
	}
}

// ChanAnyFuncErr returns a channel to receive
// all results of generator `gen`
// until `err != nil`
// before close.
func ChanAnyFuncErr(gen func() (Any, error)) (out <-chan Any) {
	cha := make(chan Any)
	go chanAnyFuncErr(cha, gen)
	return cha
}

func chanAnyFuncErr(out chan<- Any, gen func() (Any, error)) {
	defer close(out)
	for {
		res, err := gen() // generate
		if err != nil {
			return
		}
		out <- res
	}
}

// End of ChanAny producers
// ===========================================================================

// ===========================================================================
// Beg of PipeAny functions

// PipeAnyFunc returns a channel to receive
// every result of action `act` applied to `inp`
// before close.
// Note: it 'could' be PipeAnyMap for functional people,
// but 'map' has a very different meaning in go lang.
func PipeAnyFunc(inp <-chan Any, act func(a Any) Any) (out <-chan Any) {
	cha := make(chan Any)
	if act == nil { // Make `nil` value useful
		act = func(a Any) Any { return a }
	}
	go pipeAnyFunc(cha, inp, act)
	return cha
}

func pipeAnyFunc(out chan<- Any, inp <-chan Any, act func(a Any) Any) {
	defer close(out)
	for i := range inp {
		out <- act(i) // apply action
	}
}

// PipeAnyBuffer returns a buffered channel with capacity `cap` to receive
// all `inp`
// before close.
func PipeAnyBuffer(inp <-chan Any, cap int) (out <-chan Any) {
	cha := make(chan Any, cap)
	go pipeAnyBuffer(cha, inp)
	return cha
}

func pipeAnyBuffer(out chan<- Any, inp <-chan Any) {
	defer close(out)
	for i := range inp {
		out <- i
	}
}

// End of PipeAny functions
// ===========================================================================

// ===========================================================================
// Beg of TubeAny closures

// TubeAnyFunc returns a closure around PipeAnyFunc (_, act).
func TubeAnyFunc(act func(a Any) Any) (tube func(inp <-chan Any) (out <-chan Any)) {

	return func(inp <-chan Any) (out <-chan Any) {
		return PipeAnyFunc(inp, act)
	}
}

// TubeAnyBuffer returns a closure around PipeAnyBuffer (_, cap).
func TubeAnyBuffer(cap int) (tube func(inp <-chan Any) (out <-chan Any)) {

	return func(inp <-chan Any) (out <-chan Any) {
		return PipeAnyBuffer(inp, cap)
	}
}

// End of TubeAny closures
// ===========================================================================

// ===========================================================================
// Beg of DoneAny terminators

// DoneAny returns a channel to receive
// one signal before close after `inp` has been drained.
func DoneAny(inp <-chan Any) (done <-chan struct{}) {
	sig := make(chan struct{})
	go doitAny(sig, inp)
	return sig
}

func doitAny(done chan<- struct{}, inp <-chan Any) {
	defer close(done)
	for i := range inp {
		_ = i // Drain inp
	}
	done <- struct{}{}
}

// DoneAnySlice returns a channel to receive
// a slice with every Any received on `inp`
// before close.
//
// Note: Unlike DoneAny, DoneAnySlice sends the fully accumulated slice, not just an event, once upon close of inp.
func DoneAnySlice(inp <-chan Any) (done <-chan []Any) {
	sig := make(chan []Any)
	go doitAnySlice(sig, inp)
	return sig
}

func doitAnySlice(done chan<- []Any, inp <-chan Any) {
	defer close(done)
	slice := []Any{}
	for i := range inp {
		slice = append(slice, i)
	}
	done <- slice
}

// DoneAnyFunc returns a channel to receive
// one signal after `act` has been applied to every `inp`
// before close.
func DoneAnyFunc(inp <-chan Any, act func(a Any)) (done <-chan struct{}) {
	sig := make(chan struct{})
	if act == nil {
		act = func(a Any) { return }
	}
	go doitAnyFunc(sig, inp, act)
	return sig
}

func doitAnyFunc(done chan<- struct{}, inp <-chan Any, act func(a Any)) {
	defer close(done)
	for i := range inp {
		act(i) // apply action
	}
	done <- struct{}{}
}

// End of DoneAny terminators
// ===========================================================================

// ===========================================================================
// Beg of FiniAny closures

// FiniAny returns a closure around `DoneAny(_)`.
func FiniAny() func(inp <-chan Any) (done <-chan struct{}) {

	return func(inp <-chan Any) (done <-chan struct{}) {
		return DoneAny(inp)
	}
}

// FiniAnySlice returns a closure around `DoneAnySlice(_)`.
func FiniAnySlice() func(inp <-chan Any) (done <-chan []Any) {

	return func(inp <-chan Any) (done <-chan []Any) {
		return DoneAnySlice(inp)
	}
}

// FiniAnyFunc returns a closure around `DoneAnyFunc(_, act)`.
func FiniAnyFunc(act func(a Any)) func(inp <-chan Any) (done <-chan struct{}) {

	return func(inp <-chan Any) (done <-chan struct{}) {
		return DoneAnyFunc(inp, act)
	}
}

// End of FiniAny closures
// ===========================================================================

// ===========================================================================
// Beg of ForkAny functions

// ForkAny returns two channels to receive every result of inp before close.
//  Note: Yes, it is a VERY simple fanout - but sometimes all You need.
func ForkAny(inp <-chan Any) (out1, out2 <-chan Any) {
	cha1 := make(chan Any)
	cha2 := make(chan Any)
	go forkAny(cha1, cha2, inp)
	return cha1, cha2
}

/* not used any more - kept for reference only.
func forkAny(out1, out2 chan<- Any, inp <-chan Any) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		out1 <- i
		out2 <- i
	}
} */

func forkAny(out1, out2 chan<- Any, inp <-chan Any) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		select { // send first to whomever is ready to receive
		case out1 <- i:
			out2 <- i
		case out2 <- i:
			out1 <- i
		}
	}
}

// End of ForkAny functions
// ===========================================================================

// ===========================================================================
// Beg of FanIn2Any simple binary Fan-In

// FanIn2Any returns a channel to receive all to receive all from both `inp1` and `inp2` before close.
func FanIn2Any(inp1, inp2 <-chan Any) (out <-chan Any) {
	cha := make(chan Any)
	go fanIn2Any(cha, inp1, inp2)
	return cha
}

/* not used any more - kept for reference only.
// fanin2Any as seen in Go Concurrency Patterns
func fanin2Any(out chan<- Any, inp1, inp2 <-chan Any) {
	for {
		select {
		case e := <-inp1:
			out <- e
		case e := <-inp2:
			out <- e
		}
	}
} */

func fanIn2Any(out chan<- Any, inp1, inp2 <-chan Any) {
	defer close(out)

	var (
		closed bool // we found a chan closed
		ok     bool // did we read sucessfully?
		e      Any  // what we've read
	)

	for !closed {
		select {
		case e, ok = <-inp1:
			if ok {
				out <- e
			} else {
				inp1 = inp2   // swap inp2 into inp1
				closed = true // break out of the loop
			}
		case e, ok = <-inp2:
			if ok {
				out <- e
			} else {
				closed = true // break out of the loop				}
			}
		}
	}

	// inp1 might not be closed yet. Drain it.
	for e = range inp1 {
		out <- e
	}
}

// End of FanIn2Any simple binary Fan-In

// ===========================================================================
// Beg of PipeAnyEnter/Leave - Flapdoors observed by a Waiter

// AnyWaiter - as implemented by `*sync.WaitGroup` -
// attends Flapdoors and keeps track of
// how many enter and how many leave.
//
// Use Your provided `*sync.WaitGroup.Wait()`
// to know when to close the facilities.
//
// Just make sure to have _all_ entrances and exits attended,
// and don't `wg.Wait()` before You've flooded the facilities.
type AnyWaiter interface {
	Add(delta int)
	Done()
	// Wait() // here no need
}

// Note: Name is generic in order to avoid multiple-declaration clashes.

// PipeAnyEnter returns a channel to receive
// all `inp`
// and registers throughput
// as arrival
// on the given `sync.WaitGroup`
// until close.
func PipeAnyEnter(inp <-chan Any, wg AnyWaiter) (out <-chan Any) {
	cha := make(chan Any)
	go pipeAnyEnter(cha, wg, inp)
	return cha
}

// PipeAnyLeave returns a channel to receive
// all `inp`
// and registers throughput
// as departure
// on the given `sync.WaitGroup`
// until close.
func PipeAnyLeave(inp <-chan Any, wg AnyWaiter) (out <-chan Any) {
	cha := make(chan Any)
	go pipeAnyLeave(cha, wg, inp)
	return cha
}

func pipeAnyEnter(out chan<- Any, wg AnyWaiter, inp <-chan Any) {
	defer close(out)
	for i := range inp {
		wg.Add(1)
		out <- i
	}
}

func pipeAnyLeave(out chan<- Any, wg AnyWaiter, inp <-chan Any) {
	defer close(out)
	for i := range inp {
		out <- i
		wg.Done()
	}
}

// TubeAnyEnter returns a closure around PipeAnyEnter (_, wg)
// registering throughput
// on the given `sync.WaitGroup`
// as arrival.
func TubeAnyEnter(wg AnyWaiter) (tube func(inp <-chan Any) (out <-chan Any)) {

	return func(inp <-chan Any) (out <-chan Any) {
		return PipeAnyEnter(inp, wg)
	}
}

// TubeAnyLeave returns a closure around PipeAnyLeave (_, wg)
// registering throughput
// on the given `sync.WaitGroup`
// as departure.
func TubeAnyLeave(wg AnyWaiter) (tube func(inp <-chan Any) (out <-chan Any)) {

	return func(inp <-chan Any) (out <-chan Any) {
		return PipeAnyLeave(inp, wg)
	}
}

// End of PipeAnyEnter/Leave - Flapdoors observed by a Waiter

// ===========================================================================
// Beg of PipeAnyDone

// PipeAnyDone returns a channel to receive every `inp` before close and a channel to signal this closing.
func PipeAnyDone(inp <-chan Any) (out <-chan Any, done <-chan struct{}) {
	cha := make(chan Any)
	doit := make(chan struct{})
	go pipeAnyDone(cha, doit, inp)
	return cha, doit
}

func pipeAnyDone(out chan<- Any, done chan<- struct{}, inp <-chan Any) {
	defer close(done)
	defer close(out)
	for i := range inp {
		out <- i
	}
	done <- struct{}{}
}

// End of PipeAnyDone

// ===========================================================================
// Beg of PlugAny - graceful terminator

// PlugAny returns a channel to receive every `inp` before close and a channel to signal this closing.
// Upon receipt of a stop signal,
// output is immediately closed,
// and for graceful termination
// any remaining input is drained before done is signalled.
func PlugAny(inp <-chan Any, stop <-chan struct{}) (out <-chan Any, done <-chan struct{}) {
	cha := make(chan Any)
	doit := make(chan struct{})
	go plugAny(cha, doit, inp, stop)
	return cha, doit
}

func plugAny(out chan<- Any, done chan<- struct{}, inp <-chan Any, stop <-chan struct{}) {
	defer close(done)

	var ok bool // did we read sucessfully?
	var e Any   // what we've read
	for {
		select {
		case e, ok = <-inp:
			if ok {
				out <- e
			} else {
				break
			}
		case <-stop:
			break
		}
	}

	close(out)

	for _ = range inp {
		// drain inp
	}

	done <- struct{}{}
}

// End of PlugAny - graceful terminator

// ===========================================================================
// Beg of PlugAnyAfter - graceful terminator

// PlugAnyAfter returns a channel to receive every `inp` before close and a channel to signal this closing.
// Upon receipt of a time signal
// (e.g. from `time.After(...)`),
// output is immediately closed,
// and for graceful termination
// any remaining input is drained before done is signalled.
func PlugAnyAfter(inp <-chan Any, after <-chan time.Time) (out <-chan Any, done <-chan struct{}) {
	cha := make(chan Any)
	doit := make(chan struct{})
	go plugAnyAfter(cha, doit, inp, after)
	return cha, doit
}

func plugAnyAfter(out chan<- Any, done chan<- struct{}, inp <-chan Any, after <-chan time.Time) {
	defer close(done)

	var ok bool // did we read sucessfully?
	var e Any   // what we've read
	for {
		select {
		case e, ok = <-inp:
			if ok {
				out <- e
			} else {
				break
			}
		case <-after:
			break
		}
	}

	close(out)

	for _ = range inp {
		// drain inp
	}

	done <- struct{}{}
}

// End of PlugAnyAfter - graceful terminator

// Note: SendAnyProxy imports "container/ring" for the expanding buffer.

// ===========================================================================
// Beg of SendAnyProxy

// BufferAnyCAP is the capacity of the buffered proxy channel in `SendAnyProxy`
const BufferAnyCAP = 10

// BufferAnyQUE is the allocated size of the circular queue in `SendAnyProxy`
const BufferAnyQUE = 16

// SendAnyProxy returns a channel to serve as a sending proxy to 'out'.
// Uses a goroutine to receive values from 'out' and store them
// in an expanding buffer, so that sending to 'out' never blocks.
//  Note: the expanding buffer is implemented via "container/ring"
func SendAnyProxy(out chan<- Any) chan<- Any {
	proxy := make(chan Any, BufferAnyCAP)
	go func() {
		n := BufferAnyQUE // the allocated size of the circular queue
		first := ring.New(n)
		last := first
		var c chan<- Any
		var e Any
		for {
			c = out
			if first == last {
				// buffer empty: disable output
				c = nil
			} else {
				e = first.Value.(Any)
			}
			select {
			case e = <-proxy:
				last.Value = e
				if last.Next() == first {
					// buffer full: expand it
					last.Link(ring.New(n))
					n *= 2
				}
				last = last.Next()
			case c <- e:
				first = first.Next()
			}
		}
	}()
	return proxy
}

// End of SendAnyProxy

// ===========================================================================
// Beg of FanAnyOut

// FanAnyOut returns a slice (of size = size) of channels
// each of which shall receive any inp before close.
func FanAnyOut(inp <-chan Any, size int) (outS [](<-chan Any)) {
	chaS := make([]chan Any, size)
	for i := 0; i < size; i++ {
		chaS[i] = make(chan Any)
	}

	go fanAnyOut(inp, chaS...)

	outS = make([]<-chan Any, size)
	for i := 0; i < size; i++ {
		outS[i] = chaS[i] // convert `chan` to `<-chan`
	}

	return outS
}

// c fanAnyOut(inp <-chan Any, outs ...chan<- Any) {
func fanAnyOut(inp <-chan Any, outs ...chan Any) {

	for i := range inp {
		for o := range outs {
			outs[o] <- i
		}
	}

	for o := range outs {
		close(outs[o])
	}

}

// End of FanAnyOut

// ===========================================================================
// Beg of ScatterAny

// ScatterAny returns a slice (of size = size) of channels
// one of which shall receive any inp before close.
func ScatterAny(inp <-chan Any, size int) (outS [](<-chan Any)) {
	chaS := make([]chan Any, size)
	for i := 0; i < size; i++ {
		chaS[i] = make(chan Any)
	}

	go scatterAny(inp, chaS...)

	outS = make([]<-chan Any, size)
	for i := 0; i < size; i++ {
		outS[i] = chaS[i] // convert `chan` to `<-chan`
	}

	return outS
}

// c scatterAny(inp <-chan Any, outS ...chan<- Any) {
// Note: go does not convert the passed slice `[]chan Any` to `[]chan<- Any` automatically.
// So, we do neither here, as we are lazy (we just call an internal helper function).
func scatterAny(inp <-chan Any, outS ...chan Any) {

	for i := range inp {
		for !trySendAny(i, outS...) {
			time.Sleep(time.Millisecond) // wait a little before retry
		} // !sent
	} // inp

	for o := range outS {
		close(outS[o])
	}
}

func trySendAny(inp Any, outS ...chan Any) bool {

	for o := range outS {

		select { // try to send
		case outS[o] <- inp:
			return true
		default:
			// keep trying
		}

	} // outS
	return false
}

// End of FanAnyOut

// ===========================================================================
// Beg of PipeAnySeen/ForkAnySeen - an "I've seen this Any before" filter / fork

// PipeAnySeen returns a channel to receive
// all `inp`
// not been seen before
// while silently dropping everything seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
// Note: PipeAnyFilterNotSeenYet might be a better name, but is fairly long.
func PipeAnySeen(inp <-chan Any) (out <-chan Any) {
	cha := make(chan Any)
	go pipeAnySeenAttr(cha, inp, nil)
	return cha
}

// PipeAnySeenAttr returns a channel to receive
// all `inp`
// whose attribute `attr` has
// not been seen before
// while silently dropping everything seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
// Note: PipeAnyFilterAttrNotSeenYet might be a better name, but is fairly long.
func PipeAnySeenAttr(inp <-chan Any, attr func(a Any) interface{}) (out <-chan Any) {
	cha := make(chan Any)
	go pipeAnySeenAttr(cha, inp, attr)
	return cha
}

// ForkAnySeen returns two channels, `new` and `old`,
// where `new` is to receive
// all `inp`
// not been seen before
// and `old`
// all `inp`
// seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
func ForkAnySeen(inp <-chan Any) (new, old <-chan Any) {
	cha1 := make(chan Any)
	cha2 := make(chan Any)
	go forkAnySeenAttr(cha1, cha2, inp, nil)
	return cha1, cha2
}

// ForkAnySeenAttr returns two channels, `new` and `old`,
// where `new` is to receive
// all `inp`
// whose attribute `attr` has
// not been seen before
// and `old`
// all `inp`
// seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
func ForkAnySeenAttr(inp <-chan Any, attr func(a Any) interface{}) (new, old <-chan Any) {
	cha1 := make(chan Any)
	cha2 := make(chan Any)
	go forkAnySeenAttr(cha1, cha2, inp, attr)
	return cha1, cha2
}

func pipeAnySeenAttr(out chan<- Any, inp <-chan Any, attr func(a Any) interface{}) {
	defer close(out)

	if attr == nil { // Make `nil` value useful
		attr = func(a Any) interface{} { return a }
	}

	seen := sync.Map{}
	for i := range inp {
		if _, visited := seen.LoadOrStore(attr(i), struct{}{}); visited {
			// drop i silently
		} else {
			out <- i
		}
	}
}

func forkAnySeenAttr(new, old chan<- Any, inp <-chan Any, attr func(a Any) interface{}) {
	defer close(new)
	defer close(old)

	if attr == nil { // Make `nil` value useful
		attr = func(a Any) interface{} { return a }
	}

	seen := sync.Map{}
	for i := range inp {
		if _, visited := seen.LoadOrStore(attr(i), struct{}{}); visited {
			old <- i
		} else {
			new <- i
		}
	}
}

// TubeAnySeen returns a closure around PipeAnySeen()
// (silently dropping every Any seen before).
func TubeAnySeen() (tube func(inp <-chan Any) (out <-chan Any)) {

	return func(inp <-chan Any) (out <-chan Any) {
		return PipeAnySeen(inp)
	}
}

// TubeAnySeenAttr returns a closure around PipeAnySeenAttr()
// (silently dropping every Any
// whose attribute `attr` was
// seen before).
func TubeAnySeenAttr(attr func(a Any) interface{}) (tube func(inp <-chan Any) (out <-chan Any)) {

	return func(inp <-chan Any) (out <-chan Any) {
		return PipeAnySeenAttr(inp, attr)
	}
}

// End of PipeAnySeen/ForkAnySeen - an "I've seen this Any before" filter / fork

// ===========================================================================
// Beg of FanAnyIns

// FanAnyIns returns a channel to receive all inputs arriving
// on variadic inps
// before closing
//
//  Ref: https://blog.golang.org/pipelines
//  Ref: https://github.com/QuentinPerez/go-stuff/channel/Fan-out-Fan-in/main.go
func FanAnyIns(inps ...<-chan Any) (out <-chan Any) {
	cha := make(chan Any)

	var wg sync.WaitGroup
	wg.Add(len(inps))

	go func(wg sync.WaitGroup, out chan Any) { // Spawn "close(out)" once all inps are done
		wg.Wait()
		close(out)
	}(wg, cha)

	for i := range inps {
		go func(out chan<- Any, inp <-chan Any) { // Spawn "output(c)"s
			defer wg.Done()
			for i := range inp {
				out <- i
			}
		}(cha, inps[i])
	}

	return cha
}

// End of FanAnyIns

// ===========================================================================
// Beg of Fan2Any easy fan-in's

// Fan2Any returns a channel to receive
// everything from the given original channel `ori`
// as well as
// all inputs
// before close.
func Fan2Any(ori <-chan Any, inp ...Any) (out <-chan Any) {
	return FanIn2Any(ori, ChanAny(inp...))
}

// Fan2AnySlice returns a channel to receive
// everything from the given original channel `ori`
// as well as
// all inputs
// before close.
func Fan2AnySlice(ori <-chan Any, inp ...[]Any) (out <-chan Any) {
	return FanIn2Any(ori, ChanAnySlice(inp...))
}

// Fan2AnyChan returns a channel to receive
// everything from the given original channel `ori`
// as well as
// from the the input channel `inp`
// before close.
// Note: Fan2AnyChan is nothing but FanIn2Any
func Fan2AnyChan(ori <-chan Any, inp <-chan Any) (out <-chan Any) {
	return FanIn2Any(ori, inp)
}

// Fan2AnyFuncNok returns a channel to receive
// everything from the given original channel `ori`
// as well as
// all results of generator `gen`
// until `!ok`
// before close.
func Fan2AnyFuncNok(ori <-chan Any, gen func() (Any, bool)) (out <-chan Any) {
	return FanIn2Any(ori, ChanAnyFuncNok(gen))
}

// Fan2AnyFuncErr returns a channel to receive
// everything from the given original channel `ori`
// as well as
// all results of generator `gen`
// until `err != nil`
// before close.
func Fan2AnyFuncErr(ori <-chan Any, gen func() (Any, error)) (out <-chan Any) {
	return FanIn2Any(ori, ChanAnyFuncErr(gen))
}

// End of Fan2Any easy fan-in's

// ===========================================================================
// Beg of MergeAny

// MergeAny returns a channel to receive all inputs sorted and free of duplicates.
// Each input channel needs to be sorted ascending and free of duplicates.
// The passed binary boolean function `less` defines the applicable order.
//  Note: If no inputs are given, a closed channel is returned.
func MergeAny(less func(i, j Any) bool, inps ...<-chan Any) (out <-chan Any) {

	if len(inps) < 1 { // none: return a closed channel
		cha := make(chan Any)
		defer close(cha)
		return cha
	} else if len(inps) < 2 { // just one: return it
		return inps[0]
	} else { // tail recurse
		return mergeAny2(less, inps[0], MergeAny(less, inps[1:]...))
	}
}

// mergeAny2 takes two (eager) channels of comparable types,
// each of which needs to be sorted ascending and free of duplicates,
// and merges them into the returned channel, which will be sorted ascending and free of duplicates.
func mergeAny2(less func(i, j Any) bool, i1, i2 <-chan Any) (out <-chan Any) {
	cha := make(chan Any)
	go func(out chan<- Any, i1, i2 <-chan Any) {
		defer close(out)
		var (
			clos1, clos2 bool // we found the chan closed
			buff1, buff2 bool // we've read 'from', but not sent (yet)
			ok           bool // did we read sucessfully?
			from1, from2 Any  // what we've read
		)

		for !clos1 || !clos2 {

			if !clos1 && !buff1 {
				if from1, ok = <-i1; ok {
					buff1 = true
				} else {
					clos1 = true
				}
			}

			if !clos2 && !buff2 {
				if from2, ok = <-i2; ok {
					buff2 = true
				} else {
					clos2 = true
				}
			}

			if clos1 && !buff1 {
				from1 = from2
			}
			if clos2 && !buff2 {
				from2 = from1
			}

			if less(from1, from2) {
				out <- from1
				buff1 = false
			} else if less(from2, from1) {
				out <- from2
				buff2 = false
			} else {
				out <- from1 // == from2
				buff1 = false
				buff2 = false
			}
		}
	}(cha, i1, i2)
	return cha
}

// Note: merge2 is not my own. Just: I forgot where found it - please accept my apologies.
// I'd love to learn about it's origin/author, so I can give credit.
// Thus: Your hint, dear reader, is highly appreciated!

// End of MergeAny

// ===========================================================================
// Beg of SameAny comparator

// inspired by go/doc/play/tree.go

// SameAny reads values from two channels in lockstep
// and iff they have the same contents then
// `true` is sent on the returned bool channel
// before close.
func SameAny(same func(a, b Any) bool, inp1, inp2 <-chan Any) (out <-chan bool) {
	cha := make(chan bool)
	go sameAny(cha, same, inp1, inp2)
	return cha
}

func sameAny(out chan<- bool, same func(a, b Any) bool, inp1, inp2 <-chan Any) {
	defer close(out)
	for {
		v1, ok1 := <-inp1
		v2, ok2 := <-inp2

		if !ok1 || !ok2 {
			out <- ok1 == ok2
			return
		}
		if !same(v1, v2) {
			out <- false
			return
		}
	}
}

// End of SameAny comparator

// ===========================================================================
// Beg of JoinAny feedback back-feeders for circular networks

// JoinAny sends inputs on the given out channel and returns a done channel to receive one signal when inp has been drained
func JoinAny(out chan<- Any, inp ...Any) (done <-chan struct{}) {
	sig := make(chan struct{})
	go joinAny(sig, out, inp...)
	return sig
}

func joinAny(done chan<- struct{}, out chan<- Any, inp ...Any) {
	defer close(done)
	for i := range inp {
		out <- inp[i]
	}
	done <- struct{}{}
}

// JoinAnySlice sends inputs on the given out channel and returns a done channel to receive one signal when inp has been drained
func JoinAnySlice(out chan<- Any, inp ...[]Any) (done <-chan struct{}) {
	sig := make(chan struct{})
	go joinAnySlice(sig, out, inp...)
	return sig
}

func joinAnySlice(done chan<- struct{}, out chan<- Any, inp ...[]Any) {
	defer close(done)
	for i := range inp {
		for j := range inp[i] {
			out <- inp[i][j]
		}
	}
	done <- struct{}{}
}

// JoinAnyChan sends inputs on the given out channel and returns a done channel to receive one signal when inp has been drained
func JoinAnyChan(out chan<- Any, inp <-chan Any) (done <-chan struct{}) {
	sig := make(chan struct{})
	go joinAnyChan(sig, out, inp)
	return sig
}

func joinAnyChan(done chan<- struct{}, out chan<- Any, inp <-chan Any) {
	defer close(done)
	for i := range inp {
		out <- i
	}
	done <- struct{}{}
}

// End of JoinAny feedback back-feeders for circular networks

// ===========================================================================
// Beg of DaisyChainAny

// ProcAny is the signature of the inner process of any linear pipe-network
//  Example: the identity core:
// samesame := func(into chan<- Any, from <-chan Any) { into <- <-from }
// Note: type ProcAny is provided for documentation purpose only.
// The implementation uses the explicit function signature
// in order to avoid some genny-related issue.
//  Note: In https://talks.golang.org/2012/waza.slide#40
// Rob Pike uses a ProcAny named `worker`.
type ProcAny func(into chan<- Any, from <-chan Any)

// Example: the identity core - see `samesame` below
var _ ProcAny = func(into chan<- Any, from <-chan Any) { into <- <-from }

// daisyAny returns a channel to receive all inp after having passed thru process `proc`.
func daisyAny(inp <-chan Any,
	proc func(into chan<- Any, from <-chan Any), // a ProcAny process
) (
	out chan Any) { // a daisy to be chained

	cha := make(chan Any)
	go proc(cha, inp)
	return cha
}

// DaisyChainAny returns a channel to receive all inp
// after having passed
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making a null value useful.
func DaisyChainAny(inp chan Any,
	procs ...func(into chan<- Any, from <-chan Any), // ProcAny processes
) (
	out chan Any) { // to receive all results

	cha := inp

	if len(procs) < 1 {
		samesame := func(into chan<- Any, from <-chan Any) { into <- <-from }
		cha = daisyAny(cha, samesame)
	} else {
		for _, proc := range procs {
			cha = daisyAny(cha, proc)
		}
	}
	return cha
}

// DaisyChaiNAny returns a channel to receive all inp
// after having passed
// `somany` times
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If `somany` is less than 1 or no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making null values useful.
//
// Note: DaisyChaiNAny(inp, 1, procs) <==> DaisyChainAny(inp, procs)
func DaisyChaiNAny(inp chan Any, somany int,
	procs ...func(into chan<- Any, from <-chan Any), // ProcAny processes
) (
	out chan Any) { // to receive all results

	cha := inp

	if somany < 1 {
		samesame := func(into chan<- Any, from <-chan Any) { into <- <-from }
		cha = daisyAny(cha, samesame)
	} else {
		for i := 0; i < somany; i++ {
			cha = DaisyChainAny(cha, procs...)
		}
	}
	return cha
}

// End of DaisyChainAny
