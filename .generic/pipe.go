// Copyright 2017 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.

package pipe

import (
	"container/ring"
	"sync"
	"time"

	"github.com/cheekybits/genny/generic"
)

// Thing is the generic type flowing thru the pipe network.
type Thing generic.Type

// ===========================================================================
// Beg of MakeThing creators

// MakeThingChan returns a new open channel
// (simply a 'chan Thing' that is).
// Note: No 'Thing-producer' is launched here yet! (as is in all the other functions).
//  This is useful to easily create corresponding variables such as:
/*
var myThingPipelineStartsHere := MakeThingChan()
// ... lot's of code to design and build Your favourite "myThingWorkflowPipeline"
   // ...
   // ... *before* You start pouring data into it, e.g. simply via:
   for drop := range water {
myThingPipelineStartsHere <- drop
   }
close(myThingPipelineStartsHere)
*/
//  Hint: especially helpful, if Your piping library operates on some hidden (non-exported) type
//  (or on a type imported from elsewhere - and You don't want/need or should(!) have to care.)
//
// Note: as always (except for PipeThingBuffer) the channel is unbuffered.
//
func MakeThingChan() (out chan Thing) {
	return make(chan Thing)
}

// End of MakeThing creators
// ===========================================================================

// ===========================================================================
// Beg of ChanThing producers

// ChanThing returns a channel to receive
// all inputs
// before close.
func ChanThing(inp ...Thing) (out <-chan Thing) {
	cha := make(chan Thing)
	go chanThing(cha, inp...)
	return cha
}

func chanThing(out chan<- Thing, inp ...Thing) {
	defer close(out)
	for i := range inp {
		out <- inp[i]
	}
}

// ChanThingSlice returns a channel to receive
// all inputs
// before close.
func ChanThingSlice(inp ...[]Thing) (out <-chan Thing) {
	cha := make(chan Thing)
	go chanThingSlice(cha, inp...)
	return cha
}

func chanThingSlice(out chan<- Thing, inp ...[]Thing) {
	defer close(out)
	for i := range inp {
		for j := range inp[i] {
			out <- inp[i][j]
		}
	}
}

// ChanThingFuncNok returns a channel to receive
// all results of generator `gen`
// until `!ok`
// before close.
func ChanThingFuncNok(gen func() (Thing, bool)) (out <-chan Thing) {
	cha := make(chan Thing)
	go chanThingFuncNok(cha, gen)
	return cha
}

func chanThingFuncNok(out chan<- Thing, gen func() (Thing, bool)) {
	defer close(out)
	for {
		res, ok := gen() // generate
		if !ok {
			return
		}
		out <- res
	}
}

// ChanThingFuncErr returns a channel to receive
// all results of generator `gen`
// until `err != nil`
// before close.
func ChanThingFuncErr(gen func() (Thing, error)) (out <-chan Thing) {
	cha := make(chan Thing)
	go chanThingFuncErr(cha, gen)
	return cha
}

func chanThingFuncErr(out chan<- Thing, gen func() (Thing, error)) {
	defer close(out)
	for {
		res, err := gen() // generate
		if err != nil {
			return
		}
		out <- res
	}
}

// End of ChanThing producers
// ===========================================================================

// ===========================================================================
// Beg of PipeThing functions

// PipeThingFunc returns a channel to receive
// every result of action `act` applied to `inp`
// before close.
// Note: it 'could' be PipeThingMap for functional people,
// but 'map' has a very different meaning in go lang.
func PipeThingFunc(inp <-chan Thing, act func(a Thing) Thing) (out <-chan Thing) {
	cha := make(chan Thing)
	if act == nil { // Make `nil` value useful
		act = func(a Thing) Thing { return a }
	}
	go pipeThingFunc(cha, inp, act)
	return cha
}

func pipeThingFunc(out chan<- Thing, inp <-chan Thing, act func(a Thing) Thing) {
	defer close(out)
	for i := range inp {
		out <- act(i) // apply action
	}
}

// PipeThingBuffer returns a buffered channel with capacity `cap` to receive
// all `inp`
// before close.
func PipeThingBuffer(inp <-chan Thing, cap int) (out <-chan Thing) {
	cha := make(chan Thing, cap)
	go pipeThingBuffer(cha, inp)
	return cha
}

func pipeThingBuffer(out chan<- Thing, inp <-chan Thing) {
	defer close(out)
	for i := range inp {
		out <- i
	}
}

// End of PipeThing functions
// ===========================================================================

// ===========================================================================
// Beg of TubeThing closures

// TubeThingFunc returns a closure around PipeThingFunc (_, act).
func TubeThingFunc(act func(a Thing) Thing) (tube func(inp <-chan Thing) (out <-chan Thing)) {

	return func(inp <-chan Thing) (out <-chan Thing) {
		return PipeThingFunc(inp, act)
	}
}

// TubeThingBuffer returns a closure around PipeThingBuffer (_, cap).
func TubeThingBuffer(cap int) (tube func(inp <-chan Thing) (out <-chan Thing)) {

	return func(inp <-chan Thing) (out <-chan Thing) {
		return PipeThingBuffer(inp, cap)
	}
}

// End of TubeThing closures
// ===========================================================================

// ===========================================================================
// Beg of DoneThing terminators

// DoneThing returns a channel to receive
// one signal before close after `inp` has been drained.
func DoneThing(inp <-chan Thing) (done <-chan struct{}) {
	sig := make(chan struct{})
	go doitThing(sig, inp)
	return sig
}

func doitThing(done chan<- struct{}, inp <-chan Thing) {
	defer close(done)
	for i := range inp {
		_ = i // Drain inp
	}
	done <- struct{}{}
}

// DoneThingSlice returns a channel to receive
// a slice with every Thing received on `inp`
// before close.
//
// Note: Unlike DoneThing, DoneThingSlice sends the fully accumulated slice, not just an event, once upon close of inp.
func DoneThingSlice(inp <-chan Thing) (done <-chan []Thing) {
	sig := make(chan []Thing)
	go doitThingSlice(sig, inp)
	return sig
}

func doitThingSlice(done chan<- []Thing, inp <-chan Thing) {
	defer close(done)
	slice := []Thing{}
	for i := range inp {
		slice = append(slice, i)
	}
	done <- slice
}

// DoneThingFunc returns a channel to receive
// one signal after `act` has been applied to every `inp`
// before close.
func DoneThingFunc(inp <-chan Thing, act func(a Thing)) (done <-chan struct{}) {
	sig := make(chan struct{})
	if act == nil {
		act = func(a Thing) { return }
	}
	go doitThingFunc(sig, inp, act)
	return sig
}

func doitThingFunc(done chan<- struct{}, inp <-chan Thing, act func(a Thing)) {
	defer close(done)
	for i := range inp {
		act(i) // apply action
	}
	done <- struct{}{}
}

// End of DoneThing terminators
// ===========================================================================

// ===========================================================================
// Beg of FiniThing closures

// FiniThing returns a closure around `DoneThing(_)`.
func FiniThing() func(inp <-chan Thing) (done <-chan struct{}) {

	return func(inp <-chan Thing) (done <-chan struct{}) {
		return DoneThing(inp)
	}
}

// FiniThingSlice returns a closure around `DoneThingSlice(_)`.
func FiniThingSlice() func(inp <-chan Thing) (done <-chan []Thing) {

	return func(inp <-chan Thing) (done <-chan []Thing) {
		return DoneThingSlice(inp)
	}
}

// FiniThingFunc returns a closure around `DoneThingFunc(_, act)`.
func FiniThingFunc(act func(a Thing)) func(inp <-chan Thing) (done <-chan struct{}) {

	return func(inp <-chan Thing) (done <-chan struct{}) {
		return DoneThingFunc(inp, act)
	}
}

// End of FiniThing closures
// ===========================================================================

// ===========================================================================
// Beg of PairThing functions

// PairThing returns a pair of channels to receive every result of inp before close.
//  Note: Yes, it is a VERY simple fanout - but sometimes all You need.
func PairThing(inp <-chan Thing) (out1, out2 <-chan Thing) {
	cha1 := make(chan Thing)
	cha2 := make(chan Thing)
	go pairThing(cha1, cha2, inp)
	return cha1, cha2
}

/* not used any more - kept for reference only.
func pairThing(out1, out2 chan<- Thing, inp <-chan Thing) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		out1 <- i
		out2 <- i
	}
} */

func pairThing(out1, out2 chan<- Thing, inp <-chan Thing) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		select { // send first to whomever is ready to receive
		case out1 <- i:
			out2 <- i
		case out2 <- i:
			out1 <- i
		}
	}
}

// End of PairThing functions
// ===========================================================================

// ===========================================================================
// Beg of ForkThing functions

// ForkThing returns two channels
// either of which is to receive
// every result of inp
// before close.
func ForkThing(inp <-chan Thing) (out1, out2 <-chan Thing) {
	cha1 := make(chan Thing)
	cha2 := make(chan Thing)
	go forkThing(cha1, cha2, inp)
	return cha1, cha2
}

/* not used any more - kept for reference only.
func forkThing(out1, out2 chan<- Thing, inp <-chan Thing) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		out1 <- i
		out2 <- i
	}
} */

func forkThing(out1, out2 chan<- Thing, inp <-chan Thing) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		select { // send first to whomever is ready to receive
		case out1 <- i:
			out2 <- i
		case out2 <- i:
			out1 <- i
		}
	}
}

// End of ForkThing functions
// ===========================================================================

// ===========================================================================
// Beg of FanIn2Thing simple binary Fan-In

// FanIn2Thing returns a channel to receive all to receive all from both `inp1` and `inp2` before close.
func FanIn2Thing(inp1, inp2 <-chan Thing) (out <-chan Thing) {
	cha := make(chan Thing)
	go fanIn2Thing(cha, inp1, inp2)
	return cha
}

/* not used any more - kept for reference only.
// fanin2Thing as seen in Go Concurrency Patterns
func fanin2Thing(out chan<- Thing, inp1, inp2 <-chan Thing) {
	for {
		select {
		case e := <-inp1:
			out <- e
		case e := <-inp2:
			out <- e
		}
	}
} */

func fanIn2Thing(out chan<- Thing, inp1, inp2 <-chan Thing) {
	defer close(out)

	var (
		closed bool  // we found a chan closed
		ok     bool  // did we read successfully?
		e      Thing // what we've read
	)

	for !closed {
		select {
		case e, ok = <-inp1:
			if ok {
				out <- e
			} else {
				inp1 = inp2   // swap inp2 into inp1
				closed = true // break out of the loop
			}
		case e, ok = <-inp2:
			if ok {
				out <- e
			} else {
				closed = true // break out of the loop				}
			}
		}
	}

	// inp1 might not be closed yet. Drain it.
	for e = range inp1 {
		out <- e
	}
}

// End of FanIn2Thing simple binary Fan-In

// ===========================================================================
// Beg of PipeThingEnter/Leave - Flapdoors observed by a Waiter

// ThingWaiter - as implemented by `*sync.WaitGroup` -
// attends Flapdoors and keeps track of
// how many enter and how many leave.
//
// Use Your provided `*sync.WaitGroup.Wait()`
// to know when to close the facilities.
//
// Just make sure to have _all_ entrances and exits attended,
// and don't `wg.Wait()` before You've flooded the facilities.
type ThingWaiter interface {
	Add(delta int)
	Done()
	// Wait() // here no need
}

// Note: Name is generic in order to avoid multiple-declaration clashes.

// PipeThingEnter returns a channel to receive
// all `inp`
// and registers throughput
// as arrival
// on the given `sync.WaitGroup`
// until close.
func PipeThingEnter(inp <-chan Thing, wg ThingWaiter) (out <-chan Thing) {
	cha := make(chan Thing)
	go pipeThingEnter(cha, wg, inp)
	return cha
}

// PipeThingLeave returns a channel to receive
// all `inp`
// and registers throughput
// as departure
// on the given `sync.WaitGroup`
// until close.
func PipeThingLeave(inp <-chan Thing, wg ThingWaiter) (out <-chan Thing) {
	cha := make(chan Thing)
	go pipeThingLeave(cha, wg, inp)
	return cha
}

func pipeThingEnter(out chan<- Thing, wg ThingWaiter, inp <-chan Thing) {
	defer close(out)
	for i := range inp {
		wg.Add(1)
		out <- i
	}
}

func pipeThingLeave(out chan<- Thing, wg ThingWaiter, inp <-chan Thing) {
	defer close(out)
	for i := range inp {
		out <- i
		wg.Done()
	}
}

// TubeThingEnter returns a closure around PipeThingEnter (_, wg)
// registering throughput
// on the given `sync.WaitGroup`
// as arrival.
func TubeThingEnter(wg ThingWaiter) (tube func(inp <-chan Thing) (out <-chan Thing)) {

	return func(inp <-chan Thing) (out <-chan Thing) {
		return PipeThingEnter(inp, wg)
	}
}

// TubeThingLeave returns a closure around PipeThingLeave (_, wg)
// registering throughput
// on the given `sync.WaitGroup`
// as departure.
func TubeThingLeave(wg ThingWaiter) (tube func(inp <-chan Thing) (out <-chan Thing)) {

	return func(inp <-chan Thing) (out <-chan Thing) {
		return PipeThingLeave(inp, wg)
	}
}

// End of PipeThingEnter/Leave - Flapdoors observed by a Waiter

// ===========================================================================
// Beg of PipeThingDone

// PipeThingDone returns a channel to receive every `inp` before close and a channel to signal this closing.
func PipeThingDone(inp <-chan Thing) (out <-chan Thing, done <-chan struct{}) {
	cha := make(chan Thing)
	doit := make(chan struct{})
	go pipeThingDone(cha, doit, inp)
	return cha, doit
}

func pipeThingDone(out chan<- Thing, done chan<- struct{}, inp <-chan Thing) {
	defer close(out)
	defer close(done)
	for i := range inp {
		out <- i
	}
	done <- struct{}{}
}

// End of PipeThingDone

// ===========================================================================
// Beg of PlugThing - graceful terminator

// PlugThing returns a channel to receive every `inp` before close and a channel to signal this closing.
// Upon receipt of a stop signal,
// output is immediately closed,
// and for graceful termination
// any remaining input is drained before done is signalled.
func PlugThing(inp <-chan Thing, stop <-chan struct{}) (out <-chan Thing, done <-chan struct{}) {
	cha := make(chan Thing)
	doit := make(chan struct{})
	go plugThing(cha, doit, inp, stop)
	return cha, doit
}

func plugThing(out chan<- Thing, done chan<- struct{}, inp <-chan Thing, stop <-chan struct{}) {
	defer close(done)

	var end bool // shall we end?
	var ok bool  // did we read successfully?
	var e Thing  // what we've read

	for !end {
		select {
		case e, ok = <-inp:
			if ok {
				out <- e
			} else {
				end = true
			}
		case <-stop:
			end = true
		}
	}

	close(out)

	for range inp {
		// drain inp
	}

	done <- struct{}{}
}

// End of PlugThing - graceful terminator

// ===========================================================================
// Beg of PlugThingAfter - graceful terminator

// PlugThingAfter returns a channel to receive every `inp` before close and a channel to signal this closing.
// Upon receipt of a time signal
// (e.g. from `time.After(...)`),
// output is immediately closed,
// and for graceful termination
// any remaining input is drained before done is signalled.
func PlugThingAfter(inp <-chan Thing, after <-chan time.Time) (out <-chan Thing, done <-chan struct{}) {
	cha := make(chan Thing)
	doit := make(chan struct{})
	go plugThingAfter(cha, doit, inp, after)
	return cha, doit
}

func plugThingAfter(out chan<- Thing, done chan<- struct{}, inp <-chan Thing, after <-chan time.Time) {
	defer close(done)

	var end bool // shall we end?
	var ok bool  // did we read successfully?
	var e Thing  // what we've read

	for !end {
		select {
		case e, ok = <-inp:
			if ok {
				out <- e
			} else {
				end = true
			}
		case <-after:
			end = true
		}
	}

	close(out)

	for range inp {
		// drain inp
	}

	done <- struct{}{}
}

// End of PlugThingAfter - graceful terminator

// Note: SendThingProxy imports "container/ring" for the expanding buffer.

// ===========================================================================
// Beg of SendThingProxy

// BufferThingCAP is the capacity of the buffered proxy channel in `SendThingProxy`
const BufferThingCAP = 10

// BufferThingQUE is the allocated size of the circular queue in `SendThingProxy`
const BufferThingQUE = 16

// SendThingProxy returns a channel to serve as a sending proxy to 'out'.
// Uses a goroutine to receive values from 'out' and store them
// in an expanding buffer, so that sending to 'out' never blocks.
//  Note: the expanding buffer is implemented via "container/ring"
func SendThingProxy(out chan<- Thing) chan<- Thing {
	proxy := make(chan Thing, BufferThingCAP)
	go func() {
		n := BufferThingQUE // the allocated size of the circular queue
		first := ring.New(n)
		last := first
		var c chan<- Thing
		var e Thing
		for {
			c = out
			if first == last {
				// buffer empty: disable output
				c = nil
			} else {
				e = first.Value.(Thing)
			}
			select {
			case e = <-proxy:
				last.Value = e
				if last.Next() == first {
					// buffer full: expand it
					last.Link(ring.New(n))
					n *= 2
				}
				last = last.Next()
			case c <- e:
				first = first.Next()
			}
		}
	}()
	return proxy
}

// End of SendThingProxy

// ===========================================================================
// Beg of FanThingOut

// FanThingOut returns a slice (of size = size) of channels
// each of which shall receive any inp before close.
func FanThingOut(inp <-chan Thing, size int) (outS [](<-chan Thing)) {
	chaS := make([]chan Thing, size)
	for i := 0; i < size; i++ {
		chaS[i] = make(chan Thing)
	}

	go fanThingOut(inp, chaS...)

	outS = make([]<-chan Thing, size)
	for i := 0; i < size; i++ {
		outS[i] = chaS[i] // convert `chan` to `<-chan`
	}

	return outS
}

// c fanThingOut(inp <-chan Thing, outs ...chan<- Thing) {
func fanThingOut(inp <-chan Thing, outs ...chan Thing) {

	for i := range inp {
		for o := range outs {
			outs[o] <- i
		}
	}

	for o := range outs {
		close(outs[o])
	}

}

// End of FanThingOut

// ===========================================================================
// Beg of ScatterThing

// ScatterThing returns a slice (of size = size) of channels
// one of which shall receive any inp before close.
func ScatterThing(inp <-chan Thing, size int) (outS [](<-chan Thing)) {
	chaS := make([]chan Thing, size)
	for i := 0; i < size; i++ {
		chaS[i] = make(chan Thing)
	}

	go scatterThing(inp, chaS...)

	outS = make([]<-chan Thing, size)
	for i := 0; i < size; i++ {
		outS[i] = chaS[i] // convert `chan` to `<-chan`
	}

	return outS
}

// c scatterThing(inp <-chan Thing, outS ...chan<- Thing) {
// Note: go does not convert the passed slice `[]chan Thing` to `[]chan<- Thing` automatically.
// So, we do neither here, as we are lazy (we just call an internal helper function).
func scatterThing(inp <-chan Thing, outS ...chan Thing) {

	for i := range inp {
		for !trySendThing(i, outS...) {
			time.Sleep(time.Millisecond) // wait a little before retry
		} // !sent
	} // inp

	for o := range outS {
		close(outS[o])
	}
}

func trySendThing(inp Thing, outS ...chan Thing) bool {

	for o := range outS {

		select { // try to send
		case outS[o] <- inp:
			return true
		default:
			// keep trying
		}

	} // outS
	return false
}

// End of FanThingOut

// ===========================================================================
// Beg of PipeThingSeen/ForkThingSeen - an "I've seen this Thing before" filter / fork

// PipeThingSeen returns a channel to receive
// all `inp`
// not been seen before
// while silently dropping everything seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
// Note: PipeThingFilterNotSeenYet might be a better name, but is fairly long.
func PipeThingSeen(inp <-chan Thing) (out <-chan Thing) {
	cha := make(chan Thing)
	go pipeThingSeenAttr(cha, inp, nil)
	return cha
}

// PipeThingSeenAttr returns a channel to receive
// all `inp`
// whose attribute `attr` has
// not been seen before
// while silently dropping everything seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
// Note: PipeThingFilterAttrNotSeenYet might be a better name, but is fairly long.
func PipeThingSeenAttr(inp <-chan Thing, attr func(a Thing) interface{}) (out <-chan Thing) {
	cha := make(chan Thing)
	go pipeThingSeenAttr(cha, inp, attr)
	return cha
}

// ForkThingSeen returns two channels, `new` and `old`,
// where `new` is to receive
// all `inp`
// not been seen before
// and `old`
// all `inp`
// seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
func ForkThingSeen(inp <-chan Thing) (new, old <-chan Thing) {
	cha1 := make(chan Thing)
	cha2 := make(chan Thing)
	go forkThingSeenAttr(cha1, cha2, inp, nil)
	return cha1, cha2
}

// ForkThingSeenAttr returns two channels, `new` and `old`,
// where `new` is to receive
// all `inp`
// whose attribute `attr` has
// not been seen before
// and `old`
// all `inp`
// seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
func ForkThingSeenAttr(inp <-chan Thing, attr func(a Thing) interface{}) (new, old <-chan Thing) {
	cha1 := make(chan Thing)
	cha2 := make(chan Thing)
	go forkThingSeenAttr(cha1, cha2, inp, attr)
	return cha1, cha2
}

func pipeThingSeenAttr(out chan<- Thing, inp <-chan Thing, attr func(a Thing) interface{}) {
	defer close(out)

	if attr == nil { // Make `nil` value useful
		attr = func(a Thing) interface{} { return a }
	}

	seen := sync.Map{}
	for i := range inp {
		if _, visited := seen.LoadOrStore(attr(i), struct{}{}); visited {
			// drop i silently
		} else {
			out <- i
		}
	}
}

func forkThingSeenAttr(new, old chan<- Thing, inp <-chan Thing, attr func(a Thing) interface{}) {
	defer close(new)
	defer close(old)

	if attr == nil { // Make `nil` value useful
		attr = func(a Thing) interface{} { return a }
	}

	seen := sync.Map{}
	for i := range inp {
		if _, visited := seen.LoadOrStore(attr(i), struct{}{}); visited {
			old <- i
		} else {
			new <- i
		}
	}
}

// TubeThingSeen returns a closure around PipeThingSeen()
// (silently dropping every Thing seen before).
func TubeThingSeen() (tube func(inp <-chan Thing) (out <-chan Thing)) {

	return func(inp <-chan Thing) (out <-chan Thing) {
		return PipeThingSeen(inp)
	}
}

// TubeThingSeenAttr returns a closure around PipeThingSeenAttr()
// (silently dropping every Thing
// whose attribute `attr` was
// seen before).
func TubeThingSeenAttr(attr func(a Thing) interface{}) (tube func(inp <-chan Thing) (out <-chan Thing)) {

	return func(inp <-chan Thing) (out <-chan Thing) {
		return PipeThingSeenAttr(inp, attr)
	}
}

// End of PipeThingSeen/ForkThingSeen - an "I've seen this Thing before" filter / fork

// ===========================================================================
// Beg of FanThingsIn

// FanThingsIn returns a channel to receive all inputs arriving
// on variadic inps
// before close.
//
//  Ref: https://blog.golang.org/pipelines
//  Ref: https://github.com/QuentinPerez/go-stuff/channel/Fan-out-Fan-in/main.go
func FanThingsIn(inps ...<-chan Thing) (out <-chan Thing) {
	cha := make(chan Thing)

	wg := new(sync.WaitGroup)
	wg.Add(len(inps))

	go func(wg *sync.WaitGroup, out chan Thing) { // Spawn "close(out)" once all inps are done
		wg.Wait()
		close(out)
	}(wg, cha)

	for i := range inps {
		go func(out chan<- Thing, inp <-chan Thing) { // Spawn "output(c)"s
			defer wg.Done()
			for i := range inp {
				out <- i
			}
		}(cha, inps[i])
	}

	return cha
}

// End of FanThingsIn

// ===========================================================================
// Beg of Fan2Thing easy fan-in's

// Fan2Thing returns a channel to receive
// everything from the given original channel `ori`
// as well as
// all inputs
// before close.
func Fan2Thing(ori <-chan Thing, inp ...Thing) (out <-chan Thing) {
	return FanIn2Thing(ori, ChanThing(inp...))
}

// Fan2ThingSlice returns a channel to receive
// everything from the given original channel `ori`
// as well as
// all inputs
// before close.
func Fan2ThingSlice(ori <-chan Thing, inp ...[]Thing) (out <-chan Thing) {
	return FanIn2Thing(ori, ChanThingSlice(inp...))
}

// Fan2ThingChan returns a channel to receive
// everything from the given original channel `ori`
// as well as
// from the the input channel `inp`
// before close.
// Note: Fan2ThingChan is nothing but FanIn2Thing
func Fan2ThingChan(ori <-chan Thing, inp <-chan Thing) (out <-chan Thing) {
	return FanIn2Thing(ori, inp)
}

// Fan2ThingFuncNok returns a channel to receive
// everything from the given original channel `ori`
// as well as
// all results of generator `gen`
// until `!ok`
// before close.
func Fan2ThingFuncNok(ori <-chan Thing, gen func() (Thing, bool)) (out <-chan Thing) {
	return FanIn2Thing(ori, ChanThingFuncNok(gen))
}

// Fan2ThingFuncErr returns a channel to receive
// everything from the given original channel `ori`
// as well as
// all results of generator `gen`
// until `err != nil`
// before close.
func Fan2ThingFuncErr(ori <-chan Thing, gen func() (Thing, error)) (out <-chan Thing) {
	return FanIn2Thing(ori, ChanThingFuncErr(gen))
}

// End of Fan2Thing easy fan-in's

// ===========================================================================
// Beg of MergeThing

// MergeThing returns a channel to receive all inputs sorted and free of duplicates.
// Each input channel needs to be sorted ascending and free of duplicates.
// The passed binary boolean function `less` defines the applicable order.
//  Note: If no inputs are given, a closed channel is returned.
func MergeThing(less func(i, j Thing) bool, inps ...<-chan Thing) (out <-chan Thing) {

	if len(inps) < 1 { // none: return a closed channel
		cha := make(chan Thing)
		defer close(cha)
		return cha
	} else if len(inps) < 2 { // just one: return it
		return inps[0]
	} else { // tail recurse
		return mergeThing2(less, inps[0], MergeThing(less, inps[1:]...))
	}
}

// mergeThing2 takes two (eager) channels of comparable types,
// each of which needs to be sorted ascending and free of duplicates,
// and merges them into the returned channel, which will be sorted ascending and free of duplicates.
func mergeThing2(less func(i, j Thing) bool, i1, i2 <-chan Thing) (out <-chan Thing) {
	cha := make(chan Thing)
	go func(out chan<- Thing, i1, i2 <-chan Thing) {
		defer close(out)
		var (
			clos1, clos2 bool  // we found the chan closed
			buff1, buff2 bool  // we've read 'from', but not sent (yet)
			ok           bool  // did we read successfully?
			from1, from2 Thing // what we've read
		)

		for !clos1 || !clos2 {

			if !clos1 && !buff1 {
				if from1, ok = <-i1; ok {
					buff1 = true
				} else {
					clos1 = true
				}
			}

			if !clos2 && !buff2 {
				if from2, ok = <-i2; ok {
					buff2 = true
				} else {
					clos2 = true
				}
			}

			if clos1 && !buff1 {
				from1 = from2
			}
			if clos2 && !buff2 {
				from2 = from1
			}

			if less(from1, from2) {
				out <- from1
				buff1 = false
			} else if less(from2, from1) {
				out <- from2
				buff2 = false
			} else {
				out <- from1 // == from2
				buff1 = false
				buff2 = false
			}
		}
	}(cha, i1, i2)
	return cha
}

// Note: merge2 is not my own. Just: I forgot where found it - please accept my apologies.
// I'd love to learn about it's origin/author, so I can give credit.
// Thus: Your hint, dear reader, is highly appreciated!

// End of MergeThing

// ===========================================================================
// Beg of SameThing comparator

// inspired by go/doc/play/tree.go

// SameThing reads values from two channels in lockstep
// and iff they have the same contents then
// `true` is sent on the returned bool channel
// before close.
func SameThing(same func(a, b Thing) bool, inp1, inp2 <-chan Thing) (out <-chan bool) {
	cha := make(chan bool)
	go sameThing(cha, same, inp1, inp2)
	return cha
}

func sameThing(out chan<- bool, same func(a, b Thing) bool, inp1, inp2 <-chan Thing) {
	defer close(out)
	for {
		v1, ok1 := <-inp1
		v2, ok2 := <-inp2

		if !ok1 || !ok2 {
			out <- ok1 == ok2
			return
		}
		if !same(v1, v2) {
			out <- false
			return
		}
	}
}

// End of SameThing comparator

// ===========================================================================
// Beg of JoinThing feedback back-feeders for circular networks

// JoinThing sends inputs on the given out channel and returns a done channel to receive one signal when inp has been drained
func JoinThing(out chan<- Thing, inp ...Thing) (done <-chan struct{}) {
	sig := make(chan struct{})
	go joinThing(sig, out, inp...)
	return sig
}

func joinThing(done chan<- struct{}, out chan<- Thing, inp ...Thing) {
	defer close(done)
	for i := range inp {
		out <- inp[i]
	}
	done <- struct{}{}
}

// JoinThingSlice sends inputs on the given out channel and returns a done channel to receive one signal when inp has been drained
func JoinThingSlice(out chan<- Thing, inp ...[]Thing) (done <-chan struct{}) {
	sig := make(chan struct{})
	go joinThingSlice(sig, out, inp...)
	return sig
}

func joinThingSlice(done chan<- struct{}, out chan<- Thing, inp ...[]Thing) {
	defer close(done)
	for i := range inp {
		for j := range inp[i] {
			out <- inp[i][j]
		}
	}
	done <- struct{}{}
}

// JoinThingChan sends inputs on the given out channel and returns a done channel to receive one signal when inp has been drained
func JoinThingChan(out chan<- Thing, inp <-chan Thing) (done <-chan struct{}) {
	sig := make(chan struct{})
	go joinThingChan(sig, out, inp)
	return sig
}

func joinThingChan(done chan<- struct{}, out chan<- Thing, inp <-chan Thing) {
	defer close(done)
	for i := range inp {
		out <- i
	}
	done <- struct{}{}
}

// End of JoinThing feedback back-feeders for circular networks

// ===========================================================================
// Beg of DaisyChainThing

// ProcThing is the signature of the inner process of any linear pipe-network
//  Example: the identity core:
// samesame := func(into chan<- Thing, from <-chan Thing) { into <- <-from }
// Note: type ProcThing is provided for documentation purpose only.
// The implementation uses the explicit function signature
// in order to avoid some genny-related issue.
//  Note: In https://talks.golang.org/2012/waza.slide#40
// Rob Pike uses a ProcThing named `worker`.
type ProcThing func(into chan<- Thing, from <-chan Thing)

// Example: the identity core - see `samesame` below
var _ ProcThing = func(into chan<- Thing, from <-chan Thing) { into <- <-from }

// daisyThing returns a channel to receive all inp after having passed thru process `proc`.
func daisyThing(inp <-chan Thing,
	proc func(into chan<- Thing, from <-chan Thing), // a ProcThing process
) (
	out chan Thing) { // a daisy to be chained

	cha := make(chan Thing)
	go proc(cha, inp)
	return cha
}

// DaisyChainThing returns a channel to receive all inp
// after having passed
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making a null value useful.
func DaisyChainThing(inp chan Thing,
	procs ...func(into chan<- Thing, from <-chan Thing), // ProcThing processes
) (
	out chan Thing) { // to receive all results

	cha := inp

	if len(procs) < 1 {
		samesame := func(into chan<- Thing, from <-chan Thing) { into <- <-from }
		cha = daisyThing(cha, samesame)
	} else {
		for _, proc := range procs {
			cha = daisyThing(cha, proc)
		}
	}
	return cha
}

// DaisyChaiNThing returns a channel to receive all inp
// after having passed
// `somany` times
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If `somany` is less than 1 or no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making null values useful.
//
// Note: DaisyChaiNThing(inp, 1, procs) <==> DaisyChainThing(inp, procs)
func DaisyChaiNThing(inp chan Thing, somany int,
	procs ...func(into chan<- Thing, from <-chan Thing), // ProcThing processes
) (
	out chan Thing) { // to receive all results

	cha := inp

	if somany < 1 {
		samesame := func(into chan<- Thing, from <-chan Thing) { into <- <-from }
		cha = daisyThing(cha, samesame)
	} else {
		for i := 0; i < somany; i++ {
			cha = DaisyChainThing(cha, procs...)
		}
	}
	return cha
}

// End of DaisyChainThing

// This file uses geanny to pull the type specific generic code
