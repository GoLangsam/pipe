// Copyright 2017 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.

package balance

import (
	"container/heap"
	"fmt"

	"github.com/cheekybits/genny/generic"
)

type Any generic.Type

// ===========================================================================
// Beg of Request

// Request is a function to be applied and channel on which to return the result.
type Request struct {
	fn func() Any // operation to perform
	c  chan Any   // channel on which to return result
}

// Beg of Fake
func workFn() (a Any) { return }

func requester(work chan<- Request) {
	cha := make(chan Any)
	for {
		// time.Sleep ....
		work <- Request{workFn, cha} // send a work request
		result := <-cha              // wait for answer
		_ = result                   // furtherProcess(result)
	}
}

func process() {
	requester(New(10))
}

// End of Fake

// End of Request
// ===========================================================================

// ===========================================================================
// Beg of Worker

// A Worker works on received requests
type Worker struct {
	requests chan Request // work to do (a buffered channel)
	pending  int          // count of pending tasks
	index    int          // index in the heap
}

// work keeps receiving requests, and for each does:
//  - reply on the requestor-provided channel the result into the request
//  - inform on the balancer-provided channel by sending itself when done
func (w *Worker) work(done chan<- *Worker) {
	for {
		req := <-w.requests // get requests from load balancer
		req.c <- req.fn()   // do the work and send the answer back to the requestor
		done <- w           // tell load balancer a task has been completed by worker w.
	}
}

// End of Worker
// ===========================================================================

// ===========================================================================
// Beg of Pool

// Pool is a slice of (pointers to) Worker and
// implements Heap: Len Less Swap Push Pop.
type Pool []*Worker

// Len reports the number of elements in the heap.
func (p *Pool) Len() int { return len(*p) }

// Less reports whether the element @ [i] should sort before the element @ [j].
func (p *Pool) Less(i, j int) bool { return (*p)[i].pending < (*p)[j].pending }

// Swap swaps the elements @ [i] and [j].
func (p *Pool) Swap(i, j int) {
	(*p)[i], (*p)[j] = (*p)[j], (*p)[i] // swap Elements
	(*p)[i].index, (*p)[j].index = i, j // adjust indices
}

// Push add v as element @ [ Len() ].
func (p *Pool) Push(v interface{}) {
	w := v.(*Worker)
	w.index = len(*p)
	*p = append(*p, w)
}

// Pop removes and returns the element @ [ Len() - 1 ].
func (p *Pool) Pop() (v interface{}) {
	*p, v = (*p)[:p.Len()-1], (*p)[p.Len()-1]
	return
}

// End of Pool
// ===========================================================================

// ===========================================================================
// Beg of Balancer

// Balancer has a Pool of Workers and a channel for Workers having finished
type Balancer struct {
	pool Pool
	done chan *Worker
}

// New returns a receive-only request channel
// processed by `cap` balanced workers
func New(cap int) chan<- Request {
	b := &Balancer{
		pool: make([]*Worker, 0, cap),
		done: make(chan *Worker),
	}

	for i := 0; i < cap; i++ { // populate the worker pool
		work := make(chan Request) // work to receive
		w := Worker{work, 0, i}    // by worker with index `i`
		b.pool[i] = &w             // as pool[i]
		go w.work(b.done)          // launch worker to work
	}

	heap.Init(&b.pool)

	work := make(chan Request)
	go b.balance(work)

	return work
}

// balance the work
func (b *Balancer) balance(work <-chan Request) {
	for {
		select {
		case req := <-work: // received a Request...
			b.dispatch(req) // ...so send it to a Worker
		case w := <-b.done: // a worker has finished ...
			b.completed(w) // ...so update its info
		}
		b.print()
	}
}

// dispatch sends Request to Worker
func (b *Balancer) dispatch(req Request) {
	w := heap.Pop(&b.pool).(*Worker) // grab least loaded worker ...
	w.requests <- req                // ... assign it the task.
	w.pending++                      // One more in it's queue.
	heap.Push(&b.pool, w)            // Push it back into its place on the heap.
}

// completed is the Job: update the Heap
func (b *Balancer) completed(w *Worker) {
	w.pending--                // one fewer in it's queue
	heap.Fix(&b.pool, w.index) // calling Fix is equivalent to, but less expensive than, calling Remove(h, i) followed by a Push of the new value.
	// heap.Remove(&b.pool, w.index) // remove it from Heap
	// heap.Push(&b.pool, w)         // put it back where it belongs
}

func (b *Balancer) print() {
	totalPending := 0
	sumsqPending := 0
	for _, w := range b.pool { // worker
		fmt.Printf("%d  ", w.pending)
		totalPending += w.pending
		sumsqPending += w.pending * w.pending
	}
	fmt.Printf("| %d  ", totalPending)
	avg := float64(totalPending) / float64(b.pool.Len())
	variance := float64(sumsqPending)/float64(len(b.pool)) - avg*avg
	fmt.Printf("| %.2f %.2f\n", avg, variance)

}

// End of Balancer
// ===========================================================================
