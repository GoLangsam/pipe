// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright 2017 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pipe

// ===========================================================================
// Beg of intDaisyChain

// intProc is the signature of the inner process of any linear pipe-network
//  Example: the identity proc:
// samesame := func(into chan<- int, from <-chan int) { into <- <-from }
// Note: type intProc is provided for documentation purpose only.
// The implementation uses the explicit function signature
// in order to avoid some genny-related issue.
//  Note: In https://talks.golang.org/2012/waza.slide#40
// Rob Pike uses a intProc named `worker`.
type intProc func(into chan<- int, from <-chan int)

// Example: the identity proc - see `samesame` below
var _ intProc = func(out chan<- int, inp <-chan int) {
	// `out <- <-inp` or `into <- <-from`
	defer close(out)
	for i := range inp {
		out <- i
	}
}

// daisyint returns a channel to receive all inp after having passed thru process `proc`.
func daisyint(
	inp <-chan int, // a daisy to be chained
	proc func(into chan<- int, from <-chan int), // a process function
) (
	out chan int, // to receive all results
) { //  Body:

	cha := make(chan int)
	go proc(cha, inp)
	return cha
}

// intDaisyChain returns a channel to receive all inp
// after having passed
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making a null value useful.
func intDaisyChain(
	inp chan int, // a daisy to be chained
	procs ...func(out chan<- int, inp <-chan int), // a process function
) (
	out chan int, // to receive all results
) { //  Body:

	cha := inp

	if len(procs) < 1 {
		samesame := func(out chan<- int, inp <-chan int) {
			// `out <- <-inp` or `into <- <-from`
			defer close(out)
			for i := range inp {
				out <- i
			}
		}
		cha = daisyint(cha, samesame)
	} else {
		for _, proc := range procs {
			cha = daisyint(cha, proc)
		}
	}
	return cha
}

// intDaisyChaiN returns a channel to receive all inp
// after having passed
// `somany` times
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If `somany` is less than 1 or no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making null values useful.
//
// Note: intDaisyChaiN(inp, 1, procs) <==> intDaisyChain(inp, procs)
func intDaisyChaiN(
	inp chan int, // a daisy to be chained
	somany int, // how many times? so many times
	procs ...func(out chan<- int, inp <-chan int), // a process function
) (
	out chan int, // to receive all results
) { //  Body:

	cha := inp

	if somany < 1 {
		samesame := func(out chan<- int, inp <-chan int) {
			// `out <- <-inp` or `into <- <-from`
			defer close(out)
			for i := range inp {
				out <- i
			}
		}
		cha = daisyint(cha, samesame)
	} else {
		for i := 0; i < somany; i++ {
			cha = intDaisyChain(cha, procs...)
		}
	}
	return cha
}

// End of intDaisyChain
// ===========================================================================
