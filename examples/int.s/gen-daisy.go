// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright 2017 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pipe

// ===========================================================================
// Beg of intDaisyChain

// intProc is the signature of the inner process of any linear pipe-network
//  Example: the identity core:
// samesame := func(into chan<- int, from <-chan int) { into <- <-from }
// Note: type intProc is provided for documentation purpose only.
// The implementation uses the explicit function signature
// in order to avoid some genny-related issue.
//  Note: In https://talks.golang.org/2012/waza.slide#40
// Rob Pike uses a intProc named `worker`.
type intProc func(into chan<- int, from <-chan int)

// Example: the identity core - see `samesame` below
var _ intProc = func(into chan<- int, from <-chan int) { into <- <-from }

// daisyint returns a channel to receive all inp after having passed thru process `proc`.
func daisyint(inp <-chan int,
	proc func(into chan<- int, from <-chan int), // a intProc process
) (
	out chan int) { // a daisy to be chained

	cha := make(chan int)
	go proc(cha, inp)
	return cha
}

// intDaisyChain returns a channel to receive all inp
// after having passed
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making a null value useful.
func intDaisyChain(inp chan int,
	procs ...func(into chan<- int, from <-chan int), // intProc processes
) (
	out chan int) { // to receive all results

	cha := inp

	if len(procs) < 1 {
		samesame := func(into chan<- int, from <-chan int) { into <- <-from }
		cha = daisyint(cha, samesame)
	} else {
		for _, proc := range procs {
			cha = daisyint(cha, proc)
		}
	}
	return cha
}

// intDaisyChaiN returns a channel to receive all inp
// after having passed
// `somany` times
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If `somany` is less than 1 or no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making null values useful.
//
// Note: intDaisyChaiN(inp, 1, procs) <==> intDaisyChain(inp, procs)
func intDaisyChaiN(inp chan int, somany int,
	procs ...func(into chan<- int, from <-chan int), // ProcInt processes
) (
	out chan int) { // to receive all results

	cha := inp

	if somany < 1 {
		samesame := func(into chan<- int, from <-chan int) { into <- <-from }
		cha = daisyint(cha, samesame)
	} else {
		for i := 0; i < somany; i++ {
			cha = intDaisyChain(cha, procs...)
		}
	}
	return cha
}

// End of intDaisyChain
