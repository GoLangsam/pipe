// Copyright 2017 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.

package pipe

import (
	"container/ring"
	"sync"
	"time"

	"github.com/cheekybits/genny/generic"
)

// Thing is the generic type flowing thru the pipe network.
type Thing generic.Type

// ThingFrom is a receive-only Thing channel
type ThingFrom <-chan Thing

// ThingInto is a send-only Thing channel
type ThingInto chan<- Thing

// ===========================================================================
// Beg of ThingMake creators

// ThingMakeChan returns a new open channel
// (simply a 'chan Thing' that is).
// Note: No 'Thing-producer' is launched here yet! (as is in all the other functions).
//  This is useful to easily create corresponding variables such as:
/*
var myThingPipelineStartsHere := ThingMakeChan()
// ... lot's of code to design and build Your favourite "myThingWorkflowPipeline"
   // ...
   // ... *before* You start pouring data into it, e.g. simply via:
   for drop := range water {
myThingPipelineStartsHere <- drop
   }
close(myThingPipelineStartsHere)
*/
//  Hint: especially helpful, if Your piping library operates on some hidden (non-exported) type
//  (or on a type imported from elsewhere - and You don't want/need or should(!) have to care.)
//
// Note: as always (except for ThingPipeBuffer) the channel is unbuffered.
//
func ThingMakeChan() (out chan Thing) {
	return make(chan Thing)
}

// End of ThingMake creators
// ===========================================================================

// ===========================================================================
// Beg of ThingChan producers

// ThingChan returns a channel to receive
// all inputs
// before close.
func ThingChan(inp ...Thing) (out ThingFrom) {
	cha := make(chan Thing)
	go chanThing(cha, inp...)
	return cha
}

func chanThing(out ThingInto, inp ...Thing) {
	defer close(out)
	for i := range inp {
		out <- inp[i]
	}
}

// ThingChanSlice returns a channel to receive
// all inputs
// before close.
func ThingChanSlice(inp ...[]Thing) (out ThingFrom) {
	cha := make(chan Thing)
	go chanThingSlice(cha, inp...)
	return cha
}

func chanThingSlice(out ThingInto, inp ...[]Thing) {
	defer close(out)
	for i := range inp {
		for j := range inp[i] {
			out <- inp[i][j]
		}
	}
}

// ThingChanFuncNok returns a channel to receive
// all results of generator `gen`
// until `!ok`
// before close.
func ThingChanFuncNok(gen func() (Thing, bool)) (out ThingFrom) {
	cha := make(chan Thing)
	go chanThingFuncNok(cha, gen)
	return cha
}

func chanThingFuncNok(out ThingInto, gen func() (Thing, bool)) {
	defer close(out)
	for {
		res, ok := gen() // generate
		if !ok {
			return
		}
		out <- res
	}
}

// ThingChanFuncErr returns a channel to receive
// all results of generator `gen`
// until `err != nil`
// before close.
func ThingChanFuncErr(gen func() (Thing, error)) (out ThingFrom) {
	cha := make(chan Thing)
	go chanThingFuncErr(cha, gen)
	return cha
}

func chanThingFuncErr(out ThingInto, gen func() (Thing, error)) {
	defer close(out)
	for {
		res, err := gen() // generate
		if err != nil {
			return
		}
		out <- res
	}
}

// End of ThingChan producers
// ===========================================================================

// ===========================================================================
// Beg of ThingPipe functions

// ThingPipeFunc returns a channel to receive
// every result of action `act` applied to `inp`
// before close.
// Note: it 'could' be ThingPipeMap for functional people,
// but 'map' has a very different meaning in go lang.
func (inp ThingFrom) ThingPipeFunc(act func(a Thing) Thing) (out ThingFrom) {
	cha := make(chan Thing)
	if act == nil { // Make `nil` value useful
		act = func(a Thing) Thing { return a }
	}
	go inp.pipeThingFunc(cha, act)
	return cha
}

func (inp ThingFrom) pipeThingFunc(out ThingInto, act func(a Thing) Thing) {
	defer close(out)
	for i := range inp {
		out <- act(i) // apply action
	}
}

// End of ThingPipe functions
// ===========================================================================

// ===========================================================================
// Beg of ThingTube closures around ThingPipe

// ThingTubeFunc returns a closure around PipeThingFunc (_, act).
func ThingTubeFunc(act func(a Thing) Thing) (tube func(inp ThingFrom) (out ThingFrom)) {

	return func(inp ThingFrom) (out ThingFrom) {
		return inp.ThingPipeFunc(act)
	}
}

// End of ThingTube closures around ThingPipe
// ===========================================================================

// ===========================================================================
// Beg of ThingDone terminators

// ThingDone returns a channel to receive
// one signal
// upon close
// and after `inp` has been drained.
func (inp ThingFrom) ThingDone() (done <-chan struct{}) {
	sig := make(chan struct{})
	go inp.doneThing(sig)
	return sig
}

func (inp ThingFrom) doneThing(done chan<- struct{}) {
	defer close(done)
	for i := range inp {
		_ = i // Drain inp
	}
	done <- struct{}{}
}

// ThingDoneSlice returns a channel to receive
// a slice with every Thing received on `inp`
// upon close.
//
// Note: Unlike ThingDone, ThingDoneSlice sends the fully accumulated slice, not just an event, once upon close of inp.
func (inp ThingFrom) ThingDoneSlice() (done <-chan []Thing) {
	sig := make(chan []Thing)
	go inp.doneThingSlice(sig)
	return sig
}

func (inp ThingFrom) doneThingSlice(done chan<- []Thing) {
	defer close(done)
	slice := []Thing{}
	for i := range inp {
		slice = append(slice, i)
	}
	done <- slice
}

// ThingDoneFunc
// will apply `act` to every `inp` and
// returns a channel to receive
// one signal
// upon close.
func (inp ThingFrom) ThingDoneFunc(act func(a Thing)) (done <-chan struct{}) {
	sig := make(chan struct{})
	if act == nil {
		act = func(a Thing) { return }
	}
	go inp.doneThingFunc(sig, act)
	return sig
}

func (inp ThingFrom) doneThingFunc(done chan<- struct{}, act func(a Thing)) {
	defer close(done)
	for i := range inp {
		act(i) // apply action
	}
	done <- struct{}{}
}

// End of ThingDone terminators
// ===========================================================================

// ===========================================================================
// Beg of ThingFini closures

// ThingFini returns a closure around `ThingDone()`.
func (inp ThingFrom) ThingFini() func(inp ThingFrom) (done <-chan struct{}) {

	return func(inp ThingFrom) (done <-chan struct{}) {
		return inp.ThingDone()
	}
}

// ThingFiniSlice returns a closure around `ThingDoneSlice()`.
func (inp ThingFrom) ThingFiniSlice() func(inp ThingFrom) (done <-chan []Thing) {

	return func(inp ThingFrom) (done <-chan []Thing) {
		return inp.ThingDoneSlice()
	}
}

// ThingFiniFunc returns a closure around `ThingDoneFunc(act)`.
func (inp ThingFrom) ThingFiniFunc(act func(a Thing)) func(inp ThingFrom) (done <-chan struct{}) {

	return func(inp ThingFrom) (done <-chan struct{}) {
		return inp.ThingDoneFunc(act)
	}
}

// End of ThingFini closures
// ===========================================================================

// ===========================================================================
// Beg of ThingPair functions

// ThingPair returns a pair of channels to receive every result of inp before close.
//  Note: Yes, it is a VERY simple fanout - but sometimes all You need.
func (inp ThingFrom) ThingPair() (out1, out2 ThingFrom) {
	cha1 := make(chan Thing)
	cha2 := make(chan Thing)
	go inp.pairThing(cha1, cha2)
	return cha1, cha2
}

/* not used - kept for reference only.
func (inp ThingFrom) pairThing(out1, out2 ThingInto, inp ThingFrom) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		out1 <- i
		out2 <- i
	}
} */

func (inp ThingFrom) pairThing(out1, out2 ThingInto) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		select { // send first to whomever is ready to receive
		case out1 <- i:
			out2 <- i
		case out2 <- i:
			out1 <- i
		}
	}
}

// End of ThingPair functions
// ===========================================================================

// ===========================================================================
// Beg of ThingFork functions

// ThingFork returns two channels
// either of which is to receive
// every result of inp
// before close.
func (inp ThingFrom) ThingFork() (out1, out2 ThingFrom) {
	cha1 := make(chan Thing)
	cha2 := make(chan Thing)
	go inp.forkThing(cha1, cha2)
	return cha1, cha2
}

/* not used - kept for reference only.
func (inp ThingFrom) forkThing(out1, out2 ThingInto) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		out1 <- i
		out2 <- i
	}
} */

func (inp ThingFrom) forkThing(out1, out2 ThingInto) {
	defer close(out1)
	defer close(out2)
	for i := range inp {
		select { // send first to whomever is ready to receive
		case out1 <- i:
			out2 <- i
		case out2 <- i:
			out1 <- i
		}
	}
}

// End of ThingFork functions
// ===========================================================================

// ===========================================================================
// Beg of ThingFanIn2 simple binary Fan-In

// ThingFanIn2 returns a channel to receive
// all from both `inp` and `inp2`
// before close.
func (inp ThingFrom) ThingFanIn2(inp2 ThingFrom) (out ThingFrom) {
	cha := make(chan Thing)
	go inp.fanIn2Thing(cha, inp2)
	return cha
}

/* not used - kept for reference only.
// (inp ThingFrom) fanin2Thing as seen in Go Concurrency Patterns
func fanin2Thing(out ThingInto, inp, inp2 ThingFrom) {
	for {
		select {
		case e := <-inp:
			out <- e
		case e := <-inp2:
			out <- e
		}
	}
} */

func (inp ThingFrom) fanIn2Thing(out ThingInto, inp2 ThingFrom) {
	defer close(out)

	var (
		closed bool  // we found a chan closed
		ok     bool  // did we read successfully?
		e      Thing // what we've read
	)

	for !closed {
		select {
		case e, ok = <-inp:
			if ok {
				out <- e
			} else {
				inp = inp2    // swap inp2 into inp
				closed = true // break out of the loop
			}
		case e, ok = <-inp2:
			if ok {
				out <- e
			} else {
				closed = true // break out of the loop				}
			}
		}
	}

	// inp might not be closed yet. Drain it.
	for e = range inp {
		out <- e
	}
}

// End of ThingFanIn2 simple binary Fan-In
// ===========================================================================

// ===========================================================================
// Beg of ThingPipeBuffered - a buffered channel with capacity `cap` to receive

// ThingPipeBuffered returns a buffered channel with capacity `cap` to receive
// all `inp`
// before close.
func (inp ThingFrom) ThingPipeBuffered(cap int) (out ThingFrom) {
	cha := make(chan Thing, cap)
	go inp.pipeThingBuffered(cha)
	return cha
}

func (inp ThingFrom) pipeThingBuffered(out ThingInto) {
	defer close(out)
	for i := range inp {
		out <- i
	}
}

// ThingTubeBuffered returns a closure around PipeThingBuffer (cap).
func (inp ThingFrom) ThingTubeBuffered(cap int) (tube func(inp ThingFrom) (out ThingFrom)) {

	return func(inp ThingFrom) (out ThingFrom) {
		return inp.ThingPipeBuffered(cap)
	}
}

// End of ThingPipeBuffered - a buffered channel with capacity `cap` to receive
// ===========================================================================

// ===========================================================================
// Beg of ThingPipeEnter/Leave - Flapdoors observed by a Waiter

// ThingWaiter - as implemented by `*sync.WaitGroup` -
// attends Flapdoors and keeps counting
// who enters and who leaves.
//
// Use ThingDoneWait to learn about
// when the facilities are closed.
//
// Note: You may also use Your provided `*sync.WaitGroup.Wait()`
// to know when to close the facilities.
// Just: ThingDoneWait is more convenient
// as it also closes the primary channel for You.
//
// Just make sure to have _all_ entrances and exits attended,
// and `Wait()` only *after* You've started flooding the facilities.
type ThingWaiter interface {
	Add(delta int)
	Done()
	Wait()
}

// Note: The name is intentionally generic in order to avoid eventual multiple-declaration clashes.

// ThingPipeEnter returns a channel to receive
// all `inp`
// and registers throughput
// as arrival
// on the given `sync.WaitGroup`
// until close.
func (inp ThingFrom) ThingPipeEnter(wg ThingWaiter) (out ThingFrom) {
	cha := make(chan Thing)
	go inp.pipeThingEnter(cha, wg)
	return cha
}

// ThingPipeLeave returns a channel to receive
// all `inp`
// and registers throughput
// as departure
// on the given `sync.WaitGroup`
// until close.
func (inp ThingFrom) ThingPipeLeave(wg ThingWaiter) (out ThingFrom) {
	cha := make(chan Thing)
	go inp.pipeThingLeave(cha, wg)
	return cha
}

// ThingDoneLeave returns a channel to receive
// one signal after
// all throughput on `inp`
// has been registered
// as departure
// on the given `sync.WaitGroup`
// before close.
func (inp ThingFrom) ThingDoneLeave(wg ThingWaiter) (done <-chan struct{}) {
	sig := make(chan struct{})
	go inp.doneThingLeave(sig, wg)
	return sig
}

func (inp ThingFrom) pipeThingEnter(out ThingInto, wg ThingWaiter) {
	defer close(out)
	for i := range inp {
		wg.Add(1)
		out <- i
	}
}

func (inp ThingFrom) pipeThingLeave(out ThingInto, wg ThingWaiter) {
	defer close(out)
	for i := range inp {
		out <- i
		wg.Done()
	}
}

func (inp ThingFrom) doneThingLeave(done chan<- struct{}, wg ThingWaiter) {
	defer close(done)
	for i := range inp {
		_ = i // discard
		wg.Done()
	}
	done <- struct{}{}
}

// ThingTubeEnter returns a closure around ThingPipeEnter (wg)
// registering throughput
// as arrival
// on the given `sync.WaitGroup`.
func (inp ThingFrom) ThingTubeEnter(wg ThingWaiter) (tube func(inp ThingFrom) (out ThingFrom)) {

	return func(inp ThingFrom) (out ThingFrom) {
		return inp.ThingPipeEnter(wg)
	}
}

// ThingTubeLeave returns a closure around ThingPipeLeave (wg)
// registering throughput
// as departure
// on the given `sync.WaitGroup`.
func (inp ThingFrom) ThingTubeLeave(wg ThingWaiter) (tube func(inp ThingFrom) (out ThingFrom)) {

	return func(inp ThingFrom) (out ThingFrom) {
		return inp.ThingPipeLeave(wg)
	}
}

// ThingFiniLeave returns a closure around `ThingDoneLeave(wg)`
// registering throughput
// as departure
// on the given `sync.WaitGroup`.
func (inp ThingFrom) ThingFiniLeave(wg ThingWaiter) func(inp ThingFrom) (done <-chan struct{}) {

	return func(inp ThingFrom) (done <-chan struct{}) {
		return inp.ThingDoneLeave(wg)
	}
}

// ThingDoneWait returns a channel to receive
// one signal
// after wg.Wait() has returned and inp has been closed
// before close.
//
// Note: Use only *after* You've started flooding the facilities.
func (inp ThingInto) ThingDoneWait(wg ThingWaiter) (done <-chan struct{}) {
	cha := make(chan struct{})
	go inp.doneThingWait(cha, wg)
	return cha
}

func (inp ThingInto) doneThingWait(done chan<- struct{}, wg ThingWaiter) {
	defer close(done)
	wg.Wait()
	close(inp)
	done <- struct{}{} // not really needed - but looks better
}

// ThingFiniWait returns a closure around `DoneThingWait(wg)`.
func (inp ThingInto) ThingFiniWait(wg ThingWaiter) func(inp ThingInto) (done <-chan struct{}) {

	return func(inp ThingInto) (done <-chan struct{}) {
		return inp.ThingDoneWait(wg)
	}
}

// End of ThingPipeEnter/Leave - Flapdoors observed by a Waiter
// ===========================================================================

// ===========================================================================
// Beg of ThingDoneFreq - receive a frequency histogram

// ThingDoneFreq returns a channel to receive
// a frequency histogram (as a `map[Thing]int64`)
// upon close.
func (inp ThingFrom) ThingDoneFreq() (freq <-chan map[Thing]int64) {
	cha := make(chan map[Thing]int64)
	go inp.doneThingFreq(cha)
	return cha
}

// ThingDoneFreqAttr returns a channel to receive
// a frequency histogram (as a `map[interface{}]int64`)
// upon close.
//
// `attr` provides the key to the frequency map.
// If `nil` is passed as `attr` then Thing is used as key.
func (inp ThingFrom) ThingDoneFreqAttr(attr func(a Thing) interface{}) (freq <-chan map[interface{}]int64) {
	cha := make(chan map[interface{}]int64)
	go inp.doneThingFreqAttr(cha, attr)
	return cha
}

func (inp ThingFrom) doneThingFreq(out chan<- map[Thing]int64) {
	defer close(out)
	freq := make(map[Thing]int64)

	for i := range inp {
		freq[i]++
	}
	out <- freq
}

func (inp ThingFrom) doneThingFreqAttr(out chan<- map[interface{}]int64, attr func(a Thing) interface{}) {
	defer close(out)
	freq := make(map[interface{}]int64)

	if attr == nil { // Make `nil` value useful
		attr = func(a Thing) interface{} { return a }
	}

	for i := range inp {
		freq[attr(i)]++
	}
	out <- freq
}

// End of ThingDoneFreq - receive a frequency histogram
// ===========================================================================

// ===========================================================================
// Beg of ThingPipeDone

// ThingPipeDone returns a channel to receive every `inp` before close and a channel to signal this closing.
func (inp ThingFrom) ThingPipeDone() (out ThingFrom, done <-chan struct{}) {
	cha := make(chan Thing)
	doit := make(chan struct{})
	go inp.pipeThingDone(cha, doit)
	return cha, doit
}

func (inp ThingFrom) pipeThingDone(out ThingInto, done chan<- struct{}) {
	defer close(out)
	defer close(done)
	for i := range inp {
		out <- i
	}
	done <- struct{}{}
}

// End of ThingPipeDone
// ===========================================================================

// ===========================================================================
// Beg of ThingPlug - graceful terminator

// ThingPlug returns a channel to receive every `inp` before close and a channel to signal this closing.
// Upon receipt of a stop signal,
// output is immediately closed,
// and for graceful termination
// any remaining input is drained before done is signalled.
func (inp ThingFrom) ThingPlug(stop <-chan struct{}) (out ThingFrom, done <-chan struct{}) {
	cha := make(chan Thing)
	doit := make(chan struct{})
	go inp.plugThing(cha, doit, stop)
	return cha, doit
}

func (inp ThingFrom) plugThing(out ThingInto, done chan<- struct{}, stop <-chan struct{}) {
	defer close(done)

	var end bool // shall we end?
	var ok bool  // did we read successfully?
	var e Thing  // what we've read

	for !end {
		select {
		case e, ok = <-inp:
			if ok {
				out <- e
			} else {
				end = true
			}
		case <-stop:
			end = true
		}
	}

	close(out)

	for range inp {
		// drain inp
	}

	done <- struct{}{}
}

// End of ThingPlug - graceful terminator
// ===========================================================================

// ===========================================================================
// Beg of ThingPlugAfter - graceful terminator

// ThingPlugAfter returns a channel to receive every `inp` before close and a channel to signal this closing.
// Upon receipt of a time signal
// (e.g. from `time.After(...)`),
// output is immediately closed,
// and for graceful termination
// any remaining input is drained before done is signalled.
func (inp ThingFrom) ThingPlugAfter(after <-chan time.Time) (out ThingFrom, done <-chan struct{}) {
	cha := make(chan Thing)
	doit := make(chan struct{})
	go inp.plugThingAfter(cha, doit, after)
	return cha, doit
}

func (inp ThingFrom) plugThingAfter(out ThingInto, done chan<- struct{}, after <-chan time.Time) {
	defer close(done)

	var end bool // shall we end?
	var ok bool  // did we read successfully?
	var e Thing  // what we've read

	for !end {
		select {
		case e, ok = <-inp:
			if ok {
				out <- e
			} else {
				end = true
			}
		case <-after:
			end = true
		}
	}

	close(out)

	for range inp {
		// drain inp
	}

	done <- struct{}{}
}

// End of ThingPlugAfter - graceful terminator
// ===========================================================================

// Note: pipeThingAdjust imports "container/ring" for the expanding buffer.

// ===========================================================================
// Beg of ThingPipeAdjust

// ThingPipeAdjust returns a channel to receive
// all `inp`
// buffered by a ThingSendProxy process
// before close.
func (inp ThingFrom) ThingPipeAdjust(sizes ...int) (out ThingFrom) {
	cap, que := sendThingProxySizes(sizes...)
	cha := make(chan Thing, cap)
	go inp.pipeThingAdjust(cha, que)
	return cha
}

// ThingTubeAdjust returns a closure around ThingPipeAdjust (_, sizes ...int).
func (inp ThingFrom) ThingTubeAdjust(sizes ...int) (tube func(inp ThingFrom) (out ThingFrom)) {

	return func(inp ThingFrom) (out ThingFrom) {
		return inp.ThingPipeAdjust(sizes...)
	}
}

// End of ThingPipeAdjust
// ===========================================================================

// ===========================================================================
// Beg of sendThingProxy

func sendThingProxySizes(sizes ...int) (cap, que int) {

	// CAP is the minimum capacity of the buffered proxy channel in `ThingSendProxy`
	const CAP = 10

	// QUE is the minimum initially allocated size of the circular queue in `ThingSendProxy`
	const QUE = 16

	cap = CAP
	que = QUE

	if len(sizes) > 0 && sizes[0] > CAP {
		que = sizes[0]
	}

	if len(sizes) > 1 && sizes[1] > QUE {
		que = sizes[1]
	}

	if len(sizes) > 2 {
		panic("ThingSendProxy: too many sizes")
	}

	return
}

// ThingSendProxy returns a channel to serve as a sending proxy to 'out'.
// Uses a goroutine to receive values from 'out' and store them
// in an expanding buffer, so that sending to 'out' never blocks.
//  Note: the expanding buffer is implemented via "container/ring"
//
// Note: ThingSendProxy is kept for the Sieve example
// and other dynamic use to be discovered
// even so it does not fit the pipe tube pattern as ThingPipeAdjust does.
func ThingSendProxy(out ThingInto, sizes ...int) (send ThingInto) {
	cap, que := sendThingProxySizes(sizes...)
	cha := make(chan Thing, cap)
	go (ThingFrom)(cha).pipeThingAdjust(out, que)
	return cha
}

// pipeThingAdjust uses an adjusting buffer to receive from 'inp'
// even so 'out' is not ready to receive yet. The buffer may grow
// until 'inp' is closed and then will shrink by every send to 'out'.
//  Note: the adjusting buffer is implemented via "container/ring"
func (inp ThingFrom) pipeThingAdjust(out ThingInto, QUE int) {
	defer close(out)
	n := QUE // the allocated size of the circular queue
	first := ring.New(n)
	last := first
	var c ThingInto
	var e Thing
	ok := true
	for ok {
		c = out
		if first == last {
			c = nil // buffer empty: disable output
		} else {
			e = first.Value.(Thing)
		}
		select {
		case e, ok = <-inp:
			if ok {
				last.Value = e
				if last.Next() == first {
					last.Link(ring.New(n)) // buffer full: expand it
					n *= 2
				}
				last = last.Next()
			}
		case c <- e:
			first = first.Next()
		}
	}

	for first != last {
		out <- first.Value.(Thing)
		first = first.Unlink(1) // first.Next()
	}
}

// End of sendThingProxy
// ===========================================================================

// ===========================================================================
// Beg of ThingFanOut

// ThingFanOut returns a slice (of size = size) of channels
// each of which shall receive any inp before close.
func (inp ThingFrom) ThingFanOut(size int) (outS [](ThingFrom)) {
	chaS := make([]chan Thing, size)
	for i := 0; i < size; i++ {
		chaS[i] = make(chan Thing)
	}

	go inp.fanThingOut(chaS...)

	outS = make([]ThingFrom, size)
	for i := 0; i < size; i++ {
		outS[i] = (ThingFrom)(chaS[i]) // convert `chan` to `<-chan`
	}

	return outS
}

// c (inp ThingFrom) fanThingOut(outs ...ThingInto) {
func (inp ThingFrom) fanThingOut(outs ...chan Thing) {

	for i := range inp {
		for o := range outs {
			outs[o] <- i
		}
	}

	for o := range outs {
		close(outs[o])
	}

}

// End of ThingFanOut
// ===========================================================================

// ===========================================================================
// Beg of ThingStrew - scatter them

// ThingStrew returns a slice (of size = size) of channels
// one of which shall receive each inp before close.
func (inp ThingFrom) ThingStrew(size int) (outS []ThingFrom) {
	chaS := make(map[chan Thing]struct{}, size)
	for i := 0; i < size; i++ {
		chaS[make(chan Thing)] = struct{}{}
	}

	go inp.strewThing(chaS)

	outS = make([]ThingFrom, size)
	i := 0
	for c := range chaS {
		outS[i] = (ThingFrom)(c) // convert `chan Thing` to ThingFrom
		i++
	}

	return outS
}

func (inp ThingFrom) strewThing(outS map[chan Thing]struct{}) {

	for i := range inp {
		for !inp.trySendThing(i, outS) {
			time.Sleep(time.Millisecond * 10) // wait a little before retry
		} // !sent
	} // inp

	for o := range outS {
		close(o)
	}
}

func (static ThingFrom) trySendThing(inp Thing, outS map[chan Thing]struct{}) bool {

	for o := range outS {

		select { // try to send
		case o <- inp:
			return true
		default:
			// keep trying
		}

	} // outS
	return false
}

// End of ThingStrew - scatter them
// ===========================================================================

// ===========================================================================
// Beg of ThingPipeSeen/ThingForkSeen - an "I've seen this Thing before" filter / forker

// ThingPipeSeen returns a channel to receive
// all `inp`
// not been seen before
// while silently dropping everything seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
// Note: ThingPipeFilterNotSeenYet might be a better name, but is fairly long.
func (inp ThingFrom) ThingPipeSeen() (out ThingFrom) {
	cha := make(chan Thing)
	go inp.pipeThingSeenAttr(cha, nil)
	return cha
}

// ThingPipeSeenAttr returns a channel to receive
// all `inp`
// whose attribute `attr` has
// not been seen before
// while silently dropping everything seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
// Note: ThingPipeFilterAttrNotSeenYet might be a better name, but is fairly long.
func (inp ThingFrom) ThingPipeSeenAttr(attr func(a Thing) interface{}) (out ThingFrom) {
	cha := make(chan Thing)
	go inp.pipeThingSeenAttr(cha, attr)
	return cha
}

// ThingForkSeen returns two channels, `new` and `old`,
// where `new` is to receive
// all `inp`
// not been seen before
// and `old`
// all `inp`
// seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
func (inp ThingFrom) ThingForkSeen() (new, old ThingFrom) {
	cha1 := make(chan Thing)
	cha2 := make(chan Thing)
	go inp.forkThingSeenAttr(cha1, cha2, nil)
	return cha1, cha2
}

// ThingForkSeenAttr returns two channels, `new` and `old`,
// where `new` is to receive
// all `inp`
// whose attribute `attr` has
// not been seen before
// and `old`
// all `inp`
// seen before
// (internally growing a `sync.Map` to discriminate)
// until close.
func (inp ThingFrom) ThingForkSeenAttr(attr func(a Thing) interface{}) (new, old ThingFrom) {
	cha1 := make(chan Thing)
	cha2 := make(chan Thing)
	go inp.forkThingSeenAttr(cha1, cha2, attr)
	return cha1, cha2
}

func (inp ThingFrom) pipeThingSeenAttr(out ThingInto, attr func(a Thing) interface{}) {
	defer close(out)

	if attr == nil { // Make `nil` value useful
		attr = func(a Thing) interface{} { return a }
	}

	seen := sync.Map{}
	for i := range inp {
		if _, visited := seen.LoadOrStore(attr(i), struct{}{}); visited {
			// drop i silently
		} else {
			out <- i
		}
	}
}

func (inp ThingFrom) forkThingSeenAttr(new, old ThingInto, attr func(a Thing) interface{}) {
	defer close(new)
	defer close(old)

	if attr == nil { // Make `nil` value useful
		attr = func(a Thing) interface{} { return a }
	}

	seen := sync.Map{}
	for i := range inp {
		if _, visited := seen.LoadOrStore(attr(i), struct{}{}); visited {
			old <- i
		} else {
			new <- i
		}
	}
}

// ThingTubeSeen returns a closure around ThingPipeSeen()
// (silently dropping every Thing seen before).
func (inp ThingFrom) ThingTubeSeen() (tube func(inp ThingFrom) (out ThingFrom)) {

	return func(inp ThingFrom) (out ThingFrom) {
		return inp.ThingPipeSeen()
	}
}

// ThingTubeSeenAttr returns a closure around ThingPipeSeenAttr(attr)
// (silently dropping every Thing
// whose attribute `attr` was
// seen before).
func (inp ThingFrom) ThingTubeSeenAttr(attr func(a Thing) interface{}) (tube func(inp ThingFrom) (out ThingFrom)) {

	return func(inp ThingFrom) (out ThingFrom) {
		return inp.ThingPipeSeenAttr(attr)
	}
}

// End of ThingPipeSeen/ThingForkSeen - an "I've seen this Thing before" filter / forker
// ===========================================================================

// ===========================================================================
// Beg of ThingFanIn

// ThingFanIn returns a channel to receive all inputs arriving
// on variadic inps
// before close.
//
//  Note: For each input one go routine is spawned to forward arrivals.
//
// See ThingFanIn1 in `fan-in1` for another implementation.
//
//  Ref: https://blog.golang.org/pipelines
//  Ref: https://github.com/QuentinPerez/go-stuff/channel/Fan-out-Fan-in/main.go
func (inp ThingFrom) ThingFanIn(inps ...ThingFrom) (out ThingFrom) {
	cha := make(chan Thing)

	wg := new(sync.WaitGroup)
	wg.Add(len(inps) + 1)

	go inp.fanInThingWaitAndClose(cha, wg) // Spawn "close(out)" once all inps are done

	go inp.fanInThing(cha, wg)
	for i := range inps {
		go inps[i].fanInThing(cha, wg) // Spawn "output(c)"s
	}

	return cha
}

func (inp ThingFrom) fanInThing(out ThingInto, wg *sync.WaitGroup) {
	defer wg.Done()
	for i := range inp {
		out <- i
	}
}

func (inp ThingFrom) fanInThingWaitAndClose(out ThingInto, wg *sync.WaitGroup) {
	wg.Wait()
	close(out)
}

// End of ThingFanIn
// ===========================================================================

// ===========================================================================
// Beg of ThingFanIn1 - fan-in using only one go routine

// ThingFanIn1 returns a channel to receive all inputs arriving
// on variadic inps
// before close.
//
//  Note: Only one go routine is used for all receives,
//  which keeps trying open inputs in round-robin fashion
//  until all inputs are closed.
//
// See ThingFanIn in `fan-in` for another implementation.
func (inp ThingFrom) ThingFanIn1(inpS ...ThingFrom) (out ThingFrom) {
	cha := make(chan Thing)
	go fanin1Thing(cha, append(inpS, inp)...)
	return cha
}

func fanin1Thing(out ThingInto, inpS ...ThingFrom) {
	defer close(out)

	open := len(inpS)                 // assume: all are open
	closed := make([]bool, len(inpS)) // assume: each is not closed

	var item Thing // item received
	var ok bool    // receive channel is open?
	var sent bool  // some v has been sent?

	for open > 0 {
		sent = false
		for i := range inpS {
			if !closed[i] {
				select { // try to receive
				case item, ok = <-inpS[i]:
					if ok {
						out <- item
						sent = true
					} else {
						closed[i] = true
						open--
					}
				default: // keep going
				} // try
			} // not closed
		} // inpS
		if !sent && open > 0 {
			time.Sleep(time.Millisecond * 10) // wait a little before retry
		}
	} // open
}

// End of ThingFanIn1 - fan-in using only one go routine
// ===========================================================================

// ===========================================================================
// Beg of ThingFan2 easy fan-in's

// ThingFan2 returns a channel to receive
// everything from `inp`
// as well as
// all inputs
// before close.
func (inp ThingFrom) ThingFan2(inps ...Thing) (out ThingFrom) {
	return inp.ThingFanIn2(ThingChan(inps...))
}

// ThingFan2Slice returns a channel to receive
// everything from `inp`
// as well as
// all inputs
// before close.
func (inp ThingFrom) ThingFan2Slice(inps ...[]Thing) (out ThingFrom) {
	return inp.ThingFanIn2(ThingChanSlice(inps...))
}

// ThingFan2Chan returns a channel to receive
// everything from `inp`
// as well as
// everything from `ori`
// before close.
// Note: ThingFan2Chan is nothing but ThingFanIn2
func (inp ThingFrom) ThingFan2Chan(ori ThingFrom) (out ThingFrom) {
	return inp.ThingFanIn2(ori)
}

// ThingFan2FuncNok returns a channel to receive
// everything from `inp`
// as well as
// all results of generator `gen`
// until `!ok`
// before close.
func (inp ThingFrom) ThingFan2FuncNok(ori ThingFrom, gen func() (Thing, bool)) (out ThingFrom) {
	return inp.ThingFanIn2(ThingChanFuncNok(gen))
}

// ThingFan2FuncErr returns a channel to receive
// everything from `inp`
// as well as
// all results of generator `gen`
// until `err != nil`
// before close.
func (inp ThingFrom) ThingFan2FuncErr(ori ThingFrom, gen func() (Thing, error)) (out ThingFrom) {
	return inp.ThingFanIn2(ThingChanFuncErr(gen))
}

// End of ThingFan2 easy fan-in's
// ===========================================================================

// ===========================================================================
// Beg of ThingMerge

// ThingMerge returns a channel to receive all inputs sorted and free of duplicates.
// Each input channel needs to be sorted ascending and free of duplicates.
// The passed binary boolean function `less` defines the applicable order.
//  Note: If no inputs are given, a closed channel is returned.
func (inp ThingFrom) ThingMerge(less func(i, j Thing) bool, inps ...ThingFrom) (out ThingFrom) {
	var inpS []ThingFrom
	if inp == nil {
		inpS = inps
	} else {
		inpS = append(inps, inp)
	}

	if len(inpS) < 1 { // none: return a closed channel
		cha := make(chan Thing)
		defer close(cha)
		return cha
	} else if len(inpS) < 2 { // just one: return it
		return inpS[0]
	} else { // tail recurse
		return inpS[0].mergeThing(less, inpS[1].ThingMerge(less, inpS[2:]...))
	}
}

// mergeThing takes two (eager) channels of comparable types,
// each of which needs to be sorted ascending and free of duplicates,
// and merges them into the returned channel, which will be sorted ascending and free of duplicates.
func (inp ThingFrom) mergeThing(less func(i, j Thing) bool, inp2 ThingFrom) (out ThingFrom) {
	cha := make(chan Thing)
	go func(out ThingInto, inp, inp2 ThingFrom) {
		defer close(out)
		var (
			clos1, clos2 bool  // we found the chan closed
			buff1, buff2 bool  // we've read 'from', but not sent (yet)
			ok           bool  // did we read successfully?
			from1, from2 Thing // what we've read
		)

		for !clos1 || !clos2 {

			if !clos1 && !buff1 {
				if from1, ok = <-inp; ok {
					buff1 = true
				} else {
					clos1 = true
				}
			}

			if !clos2 && !buff2 {
				if from2, ok = <-inp2; ok {
					buff2 = true
				} else {
					clos2 = true
				}
			}

			if clos1 && !buff1 {
				from1 = from2
			}
			if clos2 && !buff2 {
				from2 = from1
			}

			if less(from1, from2) {
				out <- from1
				buff1 = false
			} else if less(from2, from1) {
				out <- from2
				buff2 = false
			} else {
				out <- from1 // == from2
				buff1 = false
				buff2 = false
			}
		}
	}(cha, inp, inp2)
	return cha
}

// Note: mergeThing is not my own.
// Just: I forgot where found the original merge2 - please accept my apologies.
// I'd love to learn about it's origin/author, so I can give credit.
// Thus: Your hint, dear reader, is highly appreciated!

// End of ThingMerge
// ===========================================================================

// ===========================================================================
// Beg of ThingSame comparator

// inspired by go/doc/play/tree.go

// ThingSame reads values from two channels in lockstep
// and iff they have the same contents then
// `true` is sent on the returned bool channel
// before close.
func (inp ThingFrom) ThingSame(same func(a, b Thing) bool, inp2 ThingFrom) (out <-chan bool) {
	cha := make(chan bool)
	go inp.sameThing(cha, same, inp2)
	return cha
}

func (inp ThingFrom) sameThing(out chan<- bool, same func(a, b Thing) bool, inp2 ThingFrom) {
	defer close(out)
	for {
		v1, ok1 := <-inp
		v2, ok2 := <-inp2

		if !ok1 || !ok2 {
			out <- ok1 == ok2
			return
		}
		if !same(v1, v2) {
			out <- false
			return
		}
	}
}

// End of ThingSame comparator
// ===========================================================================

// ===========================================================================
// Beg of ThingJoin feedback back-feeders for circular networks

// ThingJoin sends inputs on the given out channel and returns a done channel to receive one signal when inp has been drained
func (out ThingInto) ThingJoin(inp ...Thing) (done <-chan struct{}) {
	sig := make(chan struct{})
	go out.joinThing(sig, inp...)
	return sig
}

func (out ThingInto) joinThing(done chan<- struct{}, inp ...Thing) {
	defer close(done)
	for i := range inp {
		out <- inp[i]
	}
	done <- struct{}{}
}

// ThingJoinSlice sends inputs on the given out channel and returns a done channel to receive one signal when inp has been drained
func (out ThingInto) ThingJoinSlice(inp ...[]Thing) (done <-chan struct{}) {
	sig := make(chan struct{})
	go out.joinThingSlice(sig, inp...)
	return sig
}

func (out ThingInto) joinThingSlice(done chan<- struct{}, inp ...[]Thing) {
	defer close(done)
	for i := range inp {
		for j := range inp[i] {
			out <- inp[i][j]
		}
	}
	done <- struct{}{}
}

// ThingJoinChan sends inputs on the given out channel and returns a done channel to receive one signal when inp has been drained
func (out ThingInto) ThingJoinChan(inp ThingFrom) (done <-chan struct{}) {
	sig := make(chan struct{})
	go out.joinThingChan(sig, inp)
	return sig
}

func (out ThingInto) joinThingChan(done chan<- struct{}, inp ThingFrom) {
	defer close(done)
	for i := range inp {
		out <- i
	}
	done <- struct{}{}
}

// End of ThingJoin feedback back-feeders for circular networks
// ===========================================================================

// ===========================================================================
// Beg of ThingDaisyChain

// ThingProc is the signature of the inner process of any linear pipe-network
//  Example: the identity proc:
// samesame := func(into ThingInto, from ThingFrom) { into <- <-from }
// Note: type ThingProc is provided for documentation purpose only.
// The implementation uses the explicit function signature
// in order to avoid some genny-related issue.
//  Note: In https://talks.golang.org/2012/waza.slide#40
// Rob Pike uses a ThingProc named `worker`.
type ThingProc func(into ThingInto, from ThingFrom)

// Example: the identity proc - see `samesame` below
var _ ThingProc = func(out ThingInto, inp ThingFrom) {
	// `out <- <-inp` or `into <- <-from`
	defer close(out)
	for i := range inp {
		out <- i
	}
}

// daisyThing returns a channel to receive all inp after having passed thru process `proc`.
func daisyThing(
	inp ThingFrom, // a daisy to be chained
	proc func(into ThingInto, from ThingFrom), // a process function
) (
	out chan Thing, // to receive all results
) { //  Body:

	cha := make(chan Thing)
	go proc(cha, inp)
	return cha
}

// ThingDaisyChain returns a channel to receive all inp
// after having passed
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making a null value useful.
func ThingDaisyChain(
	inp chan Thing, // a daisy to be chained
	procs ...func(out ThingInto, inp ThingFrom), // a process function
) (
	out chan Thing, // to receive all results
) { //  Body:

	cha := inp

	if len(procs) < 1 {
		samesame := func(out ThingInto, inp ThingFrom) {
			// `out <- <-inp` or `into <- <-from`
			defer close(out)
			for i := range inp {
				out <- i
			}
		}
		cha = daisyThing(cha, samesame)
	} else {
		for _, proc := range procs {
			cha = daisyThing(cha, proc)
		}
	}
	return cha
}

// ThingDaisyChaiN returns a channel to receive all inp
// after having passed
// `somany` times
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If `somany` is less than 1 or no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making null values useful.
//
// Note: ThingDaisyChaiN(inp, 1, procs) <==> ThingDaisyChain(inp, procs)
func ThingDaisyChaiN(
	inp chan Thing, // a daisy to be chained
	somany int, // how many times? so many times
	procs ...func(out ThingInto, inp ThingFrom), // a process function
) (
	out chan Thing, // to receive all results
) { //  Body:

	cha := inp

	if somany < 1 {
		samesame := func(out ThingInto, inp ThingFrom) {
			// `out <- <-inp` or `into <- <-from`
			defer close(out)
			for i := range inp {
				out <- i
			}
		}
		cha = daisyThing(cha, samesame)
	} else {
		for i := 0; i < somany; i++ {
			cha = ThingDaisyChain(cha, procs...)
		}
	}
	return cha
}

// End of ThingDaisyChain
// ===========================================================================
