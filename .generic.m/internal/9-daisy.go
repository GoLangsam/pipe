// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright 2017 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pipe

// ===========================================================================
// Beg of ThingDaisyChain

// ThingProc is the signature of the inner process of any linear pipe-network
//  Example: the identity proc:
// samesame := func(into ThingInto, from ThingFrom) { into <- <-from }
// Note: type ThingProc is provided for documentation purpose only.
// The implementation uses the explicit function signature
// in order to avoid some genny-related issue.
//  Note: In https://talks.golang.org/2012/waza.slide#40
// Rob Pike uses a ThingProc named `worker`.
type ThingProc func(into ThingInto, from ThingFrom)

// Example: the identity proc - see `samesame` below
var _ ThingProc = func(out ThingInto, inp ThingFrom) {
	// `out <- <-inp` or `into <- <-from`
	defer close(out)
	for i := range inp {
		out <- i
	}
}

// daisyThing returns a channel to receive all inp after having passed thru process `proc`.
func daisyThing(
	inp ThingFrom, // a daisy to be chained
	proc func(into ThingInto, from ThingFrom), // a process function
) (
	out chan Thing, // to receive all results
) { //  Body:

	cha := make(chan Thing)
	go proc(cha, inp)
	return cha
}

// ThingDaisyChain returns a channel to receive all inp
// after having passed
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making a null value useful.
func ThingDaisyChain(
	inp chan Thing, // a daisy to be chained
	procs ...func(out ThingInto, inp ThingFrom), // a process function
) (
	out chan Thing, // to receive all results
) { //  Body:

	cha := inp

	if len(procs) < 1 {
		samesame := func(out ThingInto, inp ThingFrom) {
			// `out <- <-inp` or `into <- <-from`
			defer close(out)
			for i := range inp {
				out <- i
			}
		}
		cha = daisyThing(cha, samesame)
	} else {
		for _, proc := range procs {
			cha = daisyThing(cha, proc)
		}
	}
	return cha
}

// ThingDaisyChaiN returns a channel to receive all inp
// after having passed
// `somany` times
// thru the process(es) (`from` right `into` left)
// before close.
//
// Note: If `somany` is less than 1 or no `tubes` are provided,
// `out` shall receive elements from `inp` unaltered (as a convenience),
// thus making null values useful.
//
// Note: ThingDaisyChaiN(inp, 1, procs) <==> ThingDaisyChain(inp, procs)
func ThingDaisyChaiN(
	inp chan Thing, // a daisy to be chained
	somany int, // how many times? so many times
	procs ...func(out ThingInto, inp ThingFrom), // a process function
) (
	out chan Thing, // to receive all results
) { //  Body:

	cha := inp

	if somany < 1 {
		samesame := func(out ThingInto, inp ThingFrom) {
			// `out <- <-inp` or `into <- <-from`
			defer close(out)
			for i := range inp {
				out <- i
			}
		}
		cha = daisyThing(cha, samesame)
	} else {
		for i := 0; i < somany; i++ {
			cha = ThingDaisyChain(cha, procs...)
		}
	}
	return cha
}

// End of ThingDaisyChain
// ===========================================================================
